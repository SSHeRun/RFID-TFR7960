C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE COMMUNICATE
OBJECT MODULE PLACED IN .\Objects\communicate.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE communicate.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\communicate.lst) TABS(2) OBJECT(.\Objects\communicate.obj)

line level    source

   1          /********************************************************************************************************
   2          * ÎÄ ¼þ Ãû£ºCOMMUNICATE.H
   3          * ¹¦    ÄÜ£ºRFIDÔÄ¶ÁÆ÷TRF7960ÓëC8051F340Î¢¿ØÖÆÆ÷Ö®¼äÍ¨ÐÅ·½Ê½Í·ÎÄ¼þ¡£
   4          * Ó²¼þÁ¬½Ó£ºC8051F340ÓëTRF7960Ö®¼äÍ¨ÐÅÓ²¼þÁ¬½Ó¹ØÏµÈçÏÂËùÊ¾£º
   5          *                C8051F340                 TRF7960
   6          *********************    PARALLEL INTERFACE    ******************************************         
   7          *               P0.7           IRQ
   8          *         P0.3                 Slave_select
   9          *               P0.2                 SIMO
  10          *               P0.1                 SOMI
  11          *               P0.0                 DATA_CLK
  12          *       P4.0             MOD
  13          *       P4.2         ASK/OOK
  14          *       P4.3         EN
  15          *
  16          * °æ    ±¾£ºV1.0
  17          * ×÷    Õß£ºEMDOOR
  18          * ÈÕ    ÆÚ£º2011-9-29
  19          *********************************************************************************************************/
  20          #include <communicate.h>
  21          #include <globals.h>
  22          #include <hardware.h>
  23          #include <c8051f340.h>
  24          #define DBG  0
  25          static unsigned char temp;
  26          static unsigned int mask = 0x80;
  27          
  28          /*********************************************************************************************************
             -*********
  29          * º¯ÊýÃû³Æ£ºWriteSingle()
  30          * ¹¦    ÄÜ£ºÐ´µ¥¸ö¼Ä´æÆ÷»òÕßÌØÊâµØÖ·µÄ¶à¸ö¼Ä´æÆ÷ÃüÁî
  31          * Èë¿Ú²ÎÊý£º*pbuf            ½«ÒªÐ´ÈëµÄÊý¾Ý           
  32          *           lenght           Ð´ÈëÊý¾ÝµÄ³¤¶È 
  33          * ³ö¿Ú²ÎÊý£ºÎÞ
  34          * Ëµ    Ã÷£ºÐ´ÃüÁî¡£
  35          **********************************************************************************************************
             -********/
  36          void WriteSingle(unsigned char *pbuf, unsigned char lenght)
  37          {
  38   1        unsigned char i,j;
  39   1          /*  SPI Î»Ä£Ê½ */
  40   1              /*-----------------------------------------------------------------------------*/
  41   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
  42   1              CLKOFF();                                   //CLKÊ±ÖÓ¹Ø±Õ£¨µÍ£©
  43   1              while(lenght > 0)
  44   1              {
  45   2                  *pbuf = (0x1f & *pbuf);                 //È¡µÍ5Î»B0-B4 ¼Ä´æÆ÷µØÖ·Êý¾Ý ¸ñÊ½Îª000XXXXX
  46   2                  for(i = 0; i < 2; i++)                  //ÒÔµ¥¸ö¼Ä´æÆ÷£¬ÏÈ·¢ËÍµØÖ·£¬ÔÙ·¢ËÍÊý¾Ý»òÃüÁî
  47   2                  {
  48   3                      for(j = 0; j < 8; j++)
  49   3                      {
  50   4                          if (*pbuf & mask)               //ÉèÖÃÊý¾ÝÎ»
  51   4                              SIMOON();
  52   4                          else
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 2   

  53   4                              SIMOOFF();
  54   4                         
  55   4                          CLKON();                        //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
  56   4                          CLKOFF();
  57   4                          mask >>= 1;                     //±êÖ¾Î»ÓÒÒÆ
  58   4                      }   /* for */
  59   3                      mask = 0x80;
  60   3                      pbuf++;
  61   3                      lenght--;
  62   3                  }/*for*/
  63   2              } /*while*/
  64   1      
  65   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
  66   1              /*-----------------------------------------------------------------------------*/
  67   1      }   /* WriteSingle */
  68          
  69          /*********************************************************************************************************
             -*********
  70          * ????:WriteCont()
  71          * ?    ?:????????????????????
  72          * ????:*pbuf            ???????           
  73          *           lenght           ??????? 
  74          * ????:?
  75          * ?    ?:????????
  76          **********************************************************************************************************
             -********/
  77          void WriteCont(unsigned char *pbuf, unsigned char lenght)
  78          {
  79   1      //#ifdef SPI_BITBANG  
  80   1          unsigned char j;
  81   1      //#endif
  82   1      //     
  83   1      //    /* ??(PAR)???? */
  84   1      //    /*==================================================================================================
             -==*/  
  85   1      //    if ((SPIMODE) == 0)
  86   1      //    {
  87   1      //        PARStartCondition();                        //??????
  88   1      //        *pbuf = (0x20 | *pbuf);                     //??B5 ??????? ????? ???001XXXXX
  89   1      //        *pbuf = (0x3f & *pbuf);                     //??6?B0-B5 ???????001XXXXX
  90   1      //        while(lenght > 0)
  91   1      //        {
  92   1      //            TRFWrite(*pbuf);                        //???????
  93   1      //            CLKON();
  94   1      //            CLKOFF();
  95   1      //            pbuf++;
  96   1      //            lenght--;
  97   1      //        }   /* while */
  98   1      
  99   1      //        PARStopCont();                              //??????
 100   1      //    } /* if ((SPIMODE) == 0) */
 101   1      //    /*==================================================================================================
             -==*/ 
 102   1      //    
 103   1      //    /* ??(SPI)???? */
 104   1      //    /*==================================================================================================
             -==*/
 105   1      //    if (SPIMODE)
 106   1      //    {
 107   1      //#ifndef SPI_BITBANG
 108   1      //        /* ??SPI?? */
 109   1      //        /*-----------------------------------------------------------------------------*/
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 3   

 110   1      //        L_SlaveSelect();                            //SS?????,SPI??
 111   1      //        *pbuf = (0x20 | *pbuf);                     //??B5 ??????? ????? ???001XXXXX
 112   1      //        *pbuf = (0x3f & *pbuf);                     //??6?B0-B5 ???????
 113   1      //        while(lenght > 0)
 114   1      //        {
 115   1      //            while (!(IFG2 & UCB0TXIFG));            //?? USCI_B0 TX ??????
 116   1      //            UCB0TXBUF = *pbuf;                      //??????TX???
 117   1      
 118   1      //            while (!(IFG2 & UCB0RXIFG));
 119   1      //            temp=UCB0RXBUF;                         //?? USCI_B0 RX ???,???????   
 120   1      
 121   1      //            pbuf++;
 122   1      //            lenght--;
 123   1      //        }   /* while */
 124   1      
 125   1      //        H_SlaveSelect();                            //SS?????,SPI??
 126   1      //        /*-----------------------------------------------------------------------------*/
 127   1      //#else
 128   1              /*  SPI ??? */
 129   1              /*-----------------------------------------------------------------------------*/
 130   1              L_SlaveSelect();                            //SS?????,SPI??
 131   1              CLKOFF();                                   //CLK????(?)
 132   1      
 133   1              *pbuf = (0x20 | *pbuf);                     //??B5 ??????? ????? ???001XXXXX
 134   1              *pbuf = (0x3f &*pbuf);                      //??6?B0-B5 ???????
 135   1              while(lenght > 0)
 136   1              {
 137   2                  for(j=0;j<8;j++)
 138   2                  {
 139   3                      if (*pbuf & mask)                   //?????
 140   3                          SIMOON();
 141   3                      else
 142   3                          SIMOOFF();
 143   3      
 144   3                      CLKON();                            //??CLK????,????
 145   3                      CLKOFF();
 146   3                      mask >>= 1;                         //?????
 147   3                  }/*for*/
 148   2      
 149   2                  mask = 0x80;                            
 150   2                  pbuf++;
 151   2                  lenght--;
 152   2              }/*while*/
 153   1      
 154   1              H_SlaveSelect();                            //SS?????,SPI??
 155   1              /*-----------------------------------------------------------------------------*/
 156   1      #endif
*** WARNING C312 IN LINE 156 OF communicate.c: misplaced endif control
 157   1      //    } /*  if (SPIMODE) */
 158   1      }   /* WriteCont */
 159          
 160          /*********************************************************************************************************
             -*********
 161          * º¯ÊýÃû³Æ£ºReadSingle()
 162          * ¹¦    ÄÜ£º¶Áµ¥¸ö¼Ä´æÆ÷
 163          * Èë¿Ú²ÎÊý£º*pbuf            ½«Òª¶ÁÈ¡µÄÊý¾Ý           
 164          *           lenght           ¶ÁÈ¡Êý¾ÝµÄ³¤¶È 
 165          * ³ö¿Ú²ÎÊý£ºÎÞ
 166          * Ëµ    Ã÷£ºÎÞ
 167          **********************************************************************************************************
             -********/
 168          void ReadSingle(unsigned char *pbuf, unsigned char lenght)
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 4   

 169          {
 170   1       unsigned char j;
 171   1           /*  SPI Î»Ä£Ê½ */
 172   1              /*-----------------------------------------------------------------------------*/
 173   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
 174   1      
 175   1              while(lenght > 0)
 176   1              {
 177   2                  *pbuf = (0x40 | *pbuf);                 //È¡Î»B6 ¼Ä´æÆ÷µØÖ·Êý¾Ý µ¥¸ö±êÖ¾Î» ¸ñÊ½Îª01XXXXXX
 178   2                  *pbuf = (0x5f &*pbuf);                  //È¡µÍ7Î»B0-B6 ¼Ä´æÆ÷µØÖ·Êý¾Ý
 179   2                  for(j = 0; j < 8; j++)
 180   2                  {
 181   3                      if (*pbuf & mask)                   //ÉèÖÃÊý¾ÝÎ»
 182   3                          SIMOON();
 183   3                      else
 184   3                          SIMOOFF();
 185   3                      
 186   3                      CLKON();                            //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 187   3                      CLKOFF();
 188   3                      mask >>= 1;                         //±êÖ¾Î»ÓÒÒÆ
 189   3                  }   /* for */
 190   2                  mask = 0x80;
 191   2      
 192   2                  *pbuf = 0;                              //¿ªÊ¼¶ÁÈ¡´¦Àí
 193   2                  for(j = 0; j < 8; j++)
 194   2                  {
 195   3                      *pbuf <<= 1;                        //Êý¾Ý×óÒÆ
 196   3                      CLKON();                            //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 197   3                      CLKOFF();
 198   3      
 199   3                      if (SOMISIGNAL)                     //ÅÐ¶ÏSOMIÒý½Å
 200   3                          *pbuf |= 1;                     //ÈôÎª¸ßµçÆ½£¬Ôò½«Êý¾Ý»òÉÏ 1
 201   3                  }   /* for */
 202   2      
 203   2                  pbuf++;
 204   2                  lenght--;
 205   2              } /* while */
 206   1      
 207   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
 208   1              /*-----------------------------------------------------------------------------*/
 209   1      }   /* ReadCont */
 210          
 211          /*********************************************************************************************************
             -*********
 212          * º¯ÊýÃû³Æ£ºReadCont()
 213          * ¹¦    ÄÜ£ºÁ¬Ðø¶Á¼Ä´æÆ÷»òÕßÌØÊâµØÖ·µÄ¶à¸ö¼Ä´æÆ÷ÃüÁî
 214          * Èë¿Ú²ÎÊý£º*pbuf            ½«Òª¶ÁÈ¡µÄÊý¾Ý           
 215          *           lenght           ¶ÁÈ¡Êý¾ÝµÄ³¤¶È 
 216          * ³ö¿Ú²ÎÊý£ºÎÞ
 217          * Ëµ    Ã÷£ºÁ¬ÐøµØÖ·Ð´ÃüÁî¡£
 218          **********************************************************************************************************
             -********/
 219          void ReadCont(unsigned char *pbuf, unsigned char lenght)
 220          {
 221   1          unsigned char j;
 222   1        /*  SPI Î»Ä£Ê½ */
 223   1              /*-----------------------------------------------------------------------------*/
 224   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
 225   1              *pbuf = (0x60 | *pbuf);                     //È¡Î»B6B5 ¼Ä´æÆ÷µØÖ·Êý¾Ý µ¥¸ö±êÖ¾Î» ¸ñÊ½Îª011XXXXX
 226   1              *pbuf = (0x7f & *pbuf);                     //È¡µÍ7Î»B0-B6 ¼Ä´æÆ÷µØÖ·Êý¾Ý
 227   1      
 228   1              for(j = 0; j < 8; j++)                      //Ð´¼Ä´æÆ÷µØÖ·
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 5   

 229   1              {
 230   2                  if (*pbuf & mask)                       //ÉèÖÃÊý¾ÝÎ»
 231   2                      SIMOON();
 232   2                  else
 233   2                      SIMOOFF();
 234   2           
 235   2                  CLKON();                                //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 236   2                  CLKOFF();
 237   2                  mask >>= 1;                             //±êÖ¾Î»ÓÒÒÆ
 238   2              }/*for*/
 239   1              mask = 0x80;
 240   1      
 241   1              while(lenght > 0)                           //¿ªÊ¼¶ÁÈ¡´¦Àí
 242   1              {
 243   2                  *pbuf = 0;                              //Çå¿Õ»º³åÇø
 244   2                  for(j = 0; j < 8; j++)
 245   2                  {
 246   3                      *pbuf <<= 1;                        //Êý¾Ý×óÒÆ
 247   3                      CLKON();                            //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 248   3                      CLKOFF();
 249   3                      if (SOMISIGNAL)
 250   3                      *pbuf |= 1;
 251   3                  }/*for*/
 252   2      
 253   2                  pbuf++;                                 //¶Á½áÊø´¦Àí
 254   2                  lenght--;
 255   2              }/* while */
 256   1      
 257   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
 258   1          
 259   1      }
 260          
 261          /*********************************************************************************************************
             -*********
 262          * º¯ÊýÃû³Æ£ºDirectCommand()
 263          * ¹¦    ÄÜ£ºÖ±½ÓÃüÁî¿É·¢ËÍÒ»¸öÃüÁîµ½ÔÄ¶ÁÆ÷Ð¾Æ¬
 264          * Èë¿Ú²ÎÊý£º*pbuf            ½«Òª·¢ËÍµÄÃüÁîÊý¾Ý           
 265          * ³ö¿Ú²ÎÊý£ºÎÞ
 266          * Ëµ    Ã÷£ºÖ±½ÓÃüÁî¡£
 267          **********************************************************************************************************
             -********/
 268          void DirectCommand(unsigned char *pbuf)
 269          {
 270   1        unsigned char j;
 271   1        /*  SPI Î»Ä£Ê½ */
 272   1              /*-----------------------------------------------------------------------------*/
 273   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
 274   1              *pbuf = (0x80 | *pbuf);                     //È¡Î»B7 ¼Ä´æÆ÷µØÖ·Êý¾Ý ÃüÁî±êÖ¾Î» ¸ñÊ½Îª1XXXXXXX
 275   1              *pbuf = (0x9f & *pbuf);                     //ÃüÁîÖµ
 276   1      
 277   1              for(j = 0; j < 8; j++)                      //Ð´¼Ä´æÆ÷µØÖ·
 278   1              {
 279   2                  if (*pbuf & mask)                       //ÉèÖÃÊý¾ÝÎ»
 280   2                      SIMOON();
 281   2                  else
 282   2                      SIMOOFF();
 283   2      
 284   2                  CLKON();                                //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 285   2                  CLKOFF();
 286   2                  mask >>= 1;                             //±êÖ¾Î»ÓÒÒÆ
 287   2              }   /* for */
 288   1              mask = 0x80;
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 6   

 289   1      
 290   1              CLKON();                                    //Ôö¼Ó¶îÍâÊ±ÖÓÂö³å
 291   1              CLKOFF();
 292   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
 293   1              /*-----------------------------------------------------------------------------*/
 294   1      
 295   1      }   /* DirectCommand */
 296          
 297          
 298          /*********************************************************************************************************
             -*********
 299          * º¯ÊýÃû³Æ£ºRAWwrite()
 300          * ¹¦    ÄÜ£ºÖ±½ÓÐ´Êý¾Ý»òÃüÁîµ½ÔÄ¶ÁÆ÷Ð¾Æ¬
 301          * Èë¿Ú²ÎÊý£º*pbuf           ½«Òª·¢ËÍµÄÃüÁîÊý¾Ý    
 302          *           lenght          Ð´ÈëÊý¾Ý»òÃüÁîµÄ³¤¶È    
 303          * ³ö¿Ú²ÎÊý£ºÎÞ
 304          * Ëµ    Ã÷£ºÖ±½ÓÐ´¡£
 305          **********************************************************************************************************
             -********/
 306          void RAWwrite(unsigned char *pbuf, unsigned char lenght)
 307          {
 308   1         unsigned char j;
 309   1               /*  SPI Î»Ä£Ê½ */
 310   1              /*-----------------------------------------------------------------------------*/
 311   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
 312   1              while(lenght > 0)
 313   1              {
 314   2                  for(j = 0; j < 8; j++)                  //Ð´¼Ä´æÆ÷µØÖ·
 315   2                  {
 316   3                      if (*pbuf & mask)                   //ÉèÖÃÊý¾ÝÎ»
 317   3                          SIMOON();
 318   3                      else
 319   3                          SIMOOFF();
 320   3      
 321   3                      CLKON();                            //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 322   3                      CLKOFF();
 323   3                      mask >>= 1;                         //±êÖ¾Î»ÓÒÒÆ
 324   3                  }   /*for*/
 325   2                  mask = 0x80;
 326   2       
 327   2                  pbuf++;
 328   2                  lenght--;
 329   2              }   /* while */
 330   1      
 331   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
 332   1      
 333   1      }   /* RAWwrite */
 334          
 335          /*********************************************************************************************************
             -*********
 336          * º¯ÊýÃû³Æ£ºInitialSettings()
 337          * ¹¦    ÄÜ£º³õÊ¼»¯TRF7960ÉèÖÃ
 338          * Èë¿Ú²ÎÊý£ºÎÞ 
 339          * ³ö¿Ú²ÎÊý£ºÎÞ
 340          * Ëµ    Ã÷£ºÉèÖÃÆµÂÊÊä³ö¼°µ÷ÖÆÉî¶È
 341          **********************************************************************************************************
             -********/
 342          void InitialSettings(void)
 343          {
 344   1          unsigned char command[2];
 345   1      
 346   1          command[0] = ModulatorControl;                  
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 7   

 347   1          command[1] = 0x21;                              // µ÷ÖÆºÍÏµÍ³Ê±ÖÓ¿ØÖÆ£º0x21 - 6.78MHz OOK(100%)
 348   1          WriteSingle(command,2);
 349   1      
 350   1      }
 351          
 352          /*********************************************************************************************************
             -*********
 353          * º¯ÊýÃû³Æ£ºInterruptHandlerReader()
 354          * ¹¦    ÄÜ£ºÔÄ¶ÁÆ÷ÖÐ¶Ï´¦Àí³ÌÐò
 355          * Èë¿Ú²ÎÊý£º*Register           ÖÐ¶Ï×´Ì¬¼Ä´æÆ÷ 
 356          * ³ö¿Ú²ÎÊý£ºÎÞ
 357          * Ëµ    Ã÷£º´¦ÀíÍâ²¿ÖÐ¶Ï·þÎñ³ÌÐò
 358          *           IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷ËµÃ÷ÈçÏÂ£º
 359          *
 360          *   Î»      Î»Ãû³Æ      ¹¦ÄÜ                ËµÃ÷
 361          *   B7      Irq_tx      TX½áÊø¶øIRQÖÃÎ»         Ö¸Ê¾TXÕýÔÚ´¦ÀíÖÐ¡£¸Ã±êÖ¾Î»ÔÚTX¿ªÊ¼Ê±±»ÉèÖÃ£¬µ«ÊÇÖÐ¶ÏÇëÇóÊÇ
             -ÔÚTXÍê³ÉÊ±²Å·¢ËÍ¡£
 362          *   B6      Irq_srx     RX¿ªÊ¼¶øIRQÖÃÎ»         Ö¸Ê¾RX SOFÒÑ¾­±»½ÓÊÕµ½²¢ÇÒRXÕýÔÚ´¦ÀíÖÐ¡£¸Ã±êÖ¾Î»ÔÚRX¿ªÊ¼Ê±
             -±»ÉèÖÃ£¬µ«ÊÇÖÐ¶ÏÇëÇóÊÇÔÚRXÍê³ÉÊ±²Å·¢ËÍ¡£
 363          *   B5      Irq_fifo    Ö¸Ê¾FIFOÎª1/3>FIFO>2/3      Ö¸Ê¾FIFO¸ß»òÕßµÍ£¨Ð¡ÓÚ4»òÕß´óÓÚ8£©¡£
 364          *   B4      Irq_err1    CRC´íÎó             ½ÓÊÕCRC
 365          *   B3      Irq_err2    ÆæÅ¼Ð£Ñé´íÎó                    (ÔÚISO15693ºÍTag-itÐ­ÒéÖÐÎ´Ê¹ÓÃ)
 366          *   B2      Irq_err3    ×Ö½Ú³ÉÖ¡»òÕßEOF´íÎó 
 367          *   B1      Irq_col     ³å×²´íÎó            ISO14443AºÍISO15693µ¥¸±ÔØ²¨¡£
 368          *   B0      Irq_noresp  ÎÞÏìÓ¦ÖÐ¶Ï          Ö¸Ê¾MCU¿ÉÒÔ·¢ËÍÏÂÒ»¸ö²ÛÃüÁî¡£
 369          **********************************************************************************************************
             -********/
 370          void InterruptHandlerReader(unsigned char *Register)
 371          {
 372   1          unsigned char len;
 373   1      
 374   1      #if DBG
                  send_byte(*Register);                            //·¢ËÍÈë¿Ú²ÎÊýÖµ
              #endif
 377   1      
 378   1          if(*Register == 0xA0)                           //A0 = 10100000 Ö¸Ê¾TX·¢ËÍ½áÊø£¬²¢ÇÒÔÚFIFOÖÐÊ£ÏÂ3×Ö½ÚÊ
             -ý¾Ý
 379   1          {                
 380   2              i_reg = 0x00;
 381   2      #if DBG
                      sendchar('.');                              //ÔÚ´«ËÍ¹ý³ÌÖÐFIFOÒÑ¾­±»Ìî³ä
              #endif
 384   2          }
 385   1      
 386   1          else if(*Register == 0x80)                      //BIT7 = 10000000 Ö¸Ê¾TX·¢ËÍ½áÊø
 387   1          {            
 388   2              i_reg = 0x00;
 389   2              *Register = Reset;                          //ÔÚTX·¢ËÍ½áÊøºó Ö´ÐÐ¸´Î»²Ù×÷
 390   2              DirectCommand(Register);
 391   2      #if DBG
                      sendchar('T');                              //TX·¢ËÍ½áÊø
              #endif
 394   2          }
 395   1      
 396   1          else if((*Register & 0x02) == 0x02)             //BIT1 = 00000010 ³å×²´íÎó
 397   1          {                           
 398   2              i_reg = 0x02;                               //ÉèÖÃRX½áÊø
 399   2      
 400   2              *Register = StopDecoders;                   //ÔÚTX·¢ËÍ½áÊøºó¸´Î»FIFO
 401   2              DirectCommand(Register);
 402   2      
 403   2              CollPoss = CollisionPosition;
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 8   

 404   2              ReadSingle(&CollPoss, 1);
 405   2      
 406   2              len = CollPoss - 0x20;                      //»ñÈ¡FIFOÖÐµÄÓÐÐ§Êý¾Ý×Ö½ÚÊýÁ¿
 407   2      #if DBG
                      sendchar('{');
                      send_byte(CollPoss);                     //·¢ËÍ³å×²·¢ÉúµÄÎ»ÖÃ
                      sendchar('}');
              #endif     
 412   2              
 413   2              if((len & 0x0f) != 0x00) 
 414   2                  len = len + 0x10;                       //Èç¹û½ÓÊÕµ½²»ÍêÕû×Ö½Ú£¬Ôò¼ÓÉÏÒ»¸ö×Ö½Ú
 415   2              len = len >> 4;
 416   2      
 417   2              if(len != 0x00)
 418   2              {
 419   3                  buf[RXTXstate] = FIFO;                  //½«½ÓÊÕµ½µÄÊý¾ÝÐ´µ½»º³åÇøµÄµ±Ç°Î»ÖÃ                  
             -             
 420   3                  ReadCont(&buf[RXTXstate], len);
 421   3                  RXTXstate = RXTXstate + len;
 422   3              }   /* if */
 423   2      
 424   2              *Register = Reset;                          //Ö´ÐÐ¸´Î»ÃüÁî
 425   2              DirectCommand(Register);
 426   2      
 427   2              *Register = IRQStatus;                      //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 428   2              *(Register + 1) = IRQMask;
 429   2      
 430   2                  ReadCont(Register, 2);
 431   2         
 432   2              IRQCLR();                                   //ÇåÖÐ¶Ï
 433   2          }
 434   1          else if(*Register == 0x40)                      //BIT6 = 01000000 ½ÓÊÕ¿ªÊ¼
 435   1          {   
 436   2              if(RXErrorFlag == 0x02)                     //RX½ÓÊÕ±êÖ¾Î»Ö¸Ê¾EOFÒÑ¾­±»½ÓÊÕ£¬²¢ÇÒÖ¸Ê¾ÔÚFIFO¼Ä´æÆ÷Ö
             -ÐÎ´±»¶Á×Ö½ÚµÄÊýÁ¿
 437   2              {
 438   3                  i_reg = 0x02;
 439   3                  return;
 440   3              }
 441   2      
 442   2              *Register = FIFOStatus;
 443   2              ReadSingle(Register, 1);                    //¶ÁÈ¡ÔÚFIFOÖÐÊ£ÏÂ×Ö½ÚµÄÊýÁ¿
 444   2              *Register = (0x0F & *Register) + 0x01;
 445   2              buf[RXTXstate] = FIFO;                      //½«½ÓÊÕµ½µÄÊý¾ÝÐ´µ½»º³åÇøµÄµ±Ç°Î»ÖÃ
 446   2                                                                                        
 447   2              ReadCont(&buf[RXTXstate], *Register);
 448   2              RXTXstate = RXTXstate +*Register;
 449   2      
 450   2              *Register = TXLenghtByte2;                  //¶ÁÈ¡ÊÇ·ñÓÐ²»ÍêÕûµÄ×Ö½Ú¼°ÆäÎ»ÊýÁ¿
 451   2              ReadCont(Register, 1);
 452   2      
 453   2              if((*Register & 0x01) == 0x01)              //00000001 ÎÞÏìÓ¦ÖÐ¶Ï
 454   2              {
 455   3                  *Register = (*Register >> 1) & 0x07;    //±ê¼ÇÇ°5Î»
 456   3                  *Register = 8 - *Register;
 457   3                  buf[RXTXstate - 1] &= 0xFF << *Register;
 458   3              }   /* if */
 459   2               
 460   2      #if DBG
                      sendchar('E');                              //·¢ËÍÎÞÏìÓ¦±êÖ¾ E
              #endif
 463   2              *Register = Reset;                          //×îºóÒ»¸ö×Ö½Ú±»¶ÁÈ¡ºó¸´Î»FIFO
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 9   

 464   2              DirectCommand(Register);
 465   2      
 466   2              i_reg = 0xFF;                               //Ö¸Ê¾½ÓÊÕº¯ÊýÕâÐ©×Ö½ÚÒÑ¾­ÊÇ×îºó×Ö½Ú
 467   2          }
 468   1          else if(*Register == 0x60)                      //0x60 = 01100000 RXÒÑ¾­Íê±Ï ²¢ÇÒÓÐ9¸ö×Ö½ÚÔÚFIFOÖÐ
 469   1          {                            
 470   2              i_reg = 0x01;                               //ÉèÖÃ±êÖ¾Î»
 471   2              buf[RXTXstate] = FIFO;
 472   2              ReadCont(&buf[RXTXstate], 9);               //´ÓFIFOÖÐ¶ÁÈ¡9¸ö×Ö½ÚÊý¾Ý
 473   2              RXTXstate = RXTXstate + 9;
 474   2      #if DBG
                      sendchar('F');                              //·¢ËÍ F ±íÊ¾FIFO»º³åÇøÂú
              #endif
 477   2              if(IRQPORT & IRQPin)                        //Èç¹ûÖÐ¶Ï¹Ü½ÅÎª¸ßµçÆ½
 478   2              {
 479   3                  *Register = IRQStatus;                  //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 480   3                  *(Register + 1) = IRQMask;
 481   3                                  //¶ÁÈ¡¼Ä´æÆ÷
 482   3                      ReadCont(Register, 2);
 483   3               
 484   3                  IRQCLR();                               //ÇåÖÐ¶Ï
 485   3      
 486   3                  if(*Register == 0x40)                   //0x40 = 01000000 ½ÓÊÕ½áÊø
 487   3                  {  
 488   4                      *Register = FIFOStatus;
 489   4                      ReadSingle(Register, 1);            //¶ÁÈ¡ÔÚFIFOÖÐÊ£ÏÂ×Ö½ÚµÄÊýÁ¿
 490   4                      *Register = 0x0F & (*Register + 0x01);
 491   4                      buf[RXTXstate] = FIFO;              //½«½ÓÊÕµ½µÄÊý¾ÝÐ´µ½»º³åÇøµÄµ±Ç°Î»ÖÃ
 492   4                                                                                        
 493   4                      ReadCont(&buf[RXTXstate], *Register);
 494   4                      RXTXstate = RXTXstate +*Register;
 495   4      
 496   4                      *Register = TXLenghtByte2;          //¶ÁÈ¡ÊÇ·ñÓÐ²»ÍêÕûµÄ×Ö½Ú¼°ÆäÎ»ÊýÁ¿
 497   4                      ReadSingle(Register, 1);         
 498   4      
 499   4                      if((*Register & 0x01) == 0x01)      //00000001 ÎÞÏìÓ¦ÖÐ¶Ï
 500   4                      {
 501   5                          *Register = (*Register >> 1) & 0x07;            //±ê¼ÇÇ°5Î»
 502   5                          *Register = 8 -*Register;
 503   5                          buf[RXTXstate - 1] &= 0xFF << *Register;
 504   5                      }   /* if */
 505   4      #if DBG
                              sendchar('E');                      //·¢ËÍÎÞÏìÓ¦±êÖ¾ E
              #endif
 508   4                      i_reg = 0xFF;                       //Ö¸Ê¾½ÓÊÕº¯ÊýÕâÐ©×Ö½ÚÒÑ¾­ÊÇ×îºó×Ö½Ú
 509   4                      *Register = Reset;                  //ÔÚ×îºó×Ö½Ú±»¶ÁÈ¡ºó¸´Î»FIFO
 510   4                      DirectCommand(Register);
 511   4                  }
 512   3                  else if(*Register == 0x50)              //0x50 = 01010000½ÓÊÕ½áÊø²¢ÇÒ·¢ÉúCRC´íÎó
 513   3                  {        
 514   4                      i_reg = 0x02;
 515   4      #if DBG
                              sendchar('x');                      //·¢ËÍCRCÐ£Ñé´íÎó±êÖ¾ x
              #endif
 518   4                  }
 519   3              }   /* if(IRQPORT & IRQPin) */
 520   2              else                                        
 521   2              {
 522   3                  Register[0] = IRQStatus;                //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 523   3                  Register[1] = IRQMask;
 524   3                  
 525   3                      ReadCont(Register, 2);              //¶ÁÈ¡¼Ä´æÆ÷
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 10  

 526   3                
 527   3                  
 528   3                  if(Register[0] == 0x00) 
 529   3                    i_reg = 0xFF;                         //Ö¸Ê¾½ÓÊÕº¯ÊýÕâÐ©×Ö½ÚÒÑ¾­ÊÇ×îºó×Ö½Ú
 530   3              }
 531   2          }
 532   1          else if((*Register & 0x10) == 0x10)             //BIT4 = 00010000 Ö¸Ê¾CRC´íÎó
 533   1          {                      
 534   2              if((*Register & 0x20) == 0x20)              //BIT5 = 00100000 Ö¸Ê¾FIFOÖÐÓÐ9¸ö×Ö½Ú
 535   2              {
 536   3                  i_reg = 0x01;                           //½ÓÊÕÍê³É
 537   3                  RXErrorFlag = 0x02;
 538   3              }
 539   2              else
 540   2                  i_reg = 0x02;                           //Í£Ö¹½ÓÊÕ        
 541   2          }
 542   1          else if((*Register & 0x04) == 0x04)             //BIT2 = 00000100  ×Ö½Ú³ÉÖ¡»òÕßEOF´íÎó
 543   1          {                       
 544   2              if((*Register & 0x20) == 0x20)              //BIT5 = 00100000 Ö¸Ê¾FIFOÖÐÓÐ9¸ö×Ö½Ú
 545   2              {
 546   3                  i_reg = 0x01;                           //½ÓÊÕÍê³É
 547   3                  RXErrorFlag = 0x02;
 548   3              }
 549   2              else
 550   2                  i_reg = 0x02;                           //Í£Ö¹½ÓÊÕ 
 551   2          }
 552   1          else if(*Register == 0x01)                      //BIT0 = 00000001 ÖÐ¶ÏÎÞÓ¦´ð
 553   1          {                      
 554   2              i_reg = 0x00;
 555   2      #if DBG
                      sendchar('N');
              #endif
 558   2          }
 559   1          else
 560   1          {     
 561   2      #if DBG    
                      send_cstring("Interrupt error");        //·¢ËÍÖÐ¶Ï´íÎó
                      send_byte(*Register);
              #endif        
 565   2              i_reg = 0x02;
 566   2      
 567   2              *Register = StopDecoders;                   //ÔÚTX·¢ËÍ½ÓÊÕºó¸´Î»FIFO
 568   2              DirectCommand(Register);
 569   2      
 570   2              *Register = Reset;
 571   2              DirectCommand(Register);
 572   2      
 573   2              *Register = IRQStatus;                      //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 574   2              *(Register + 1) = IRQMask;
 575   2      
 576   2             
 577   2                  ReadCont(Register, 2);                  //¶ÁÈ¡¼Ä´æÆ÷
 578   2              
 579   2              IRQCLR();                                   //ÇåÖÐ¶Ï
 580   2          }
 581   1      }   /* InterruptHandlerReader */
 582          
 583          /********************************************************************************************************
 584          * º¯ÊýÃû³Æ£ºPort_0()
 585          * ¹¦    ÄÜ£ºÔÄ¶ÁÆ÷ÖÐ¶ÏÈë¿Ú³ÌÐò
 586          * Èë¿Ú²ÎÊý£ºÎÞ
 587          * ³ö¿Ú²ÎÊý£ºÎÞ
C51 COMPILER V9.56.0.0   COMMUNICATE                                                       11/17/2018 14:25:55 PAGE 11  

 588          * Ëµ    Ã÷£º´¦ÀíÍâ²¿ÖÐ¶Ï·þÎñ³ÌÐò
 589          *********************************************************************************************************/
 590          void Port_0(void) interrupt 0     
 591          {
 592   1          unsigned char Register[4];
 593   1      
 594   1          StopCounter();                                  //¶¨Ê±Æ÷Í£Ö¹
 595   1      
 596   1          do
 597   1          {
 598   2              IRQCLR();                                   //Çå¶Ë¿Ú2ÖÐ¶Ï±êÖ¾Î»
 599   2              Register[0] = IRQStatus;                    //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 600   2              Register[1] = IRQMask;                      //ÐéÄâ¶Á Dummy read                                 
 601   2              ReadCont(Register, 2); //¶ÁÈ¡¼Ä´æÆ÷
 602   2              if(*Register == 0xA0)                       //A0 = 10100000 Ö¸Ê¾TX·¢ËÍ½áÊø£¬²¢ÇÒÔÚFIFOÖÐÊ£ÏÂ3×Ö½ÚÊ
             -ý¾Ý
 603   2              {   
 604   3                  goto FINISH;                            //Ìø×ªµ½FINISH´¦£¬½øÈëµÍ¹¦ºÄÄ£Ê½
 605   3              }
 606   2              
 607   2              InterruptHandlerReader(&Register[0]);       //Ö´ÐÐÖÐ¶Ï·þÎñ³ÌÐò
 608   2          }while((IRQPORT & IRQPin) == IRQPin);           //Ìõ¼þÖ´ÐÐ
 609   1      FINISH:
 610   1         PCON &= ~0X02;
 611   1        // return;
 612   1      }
 613          
 614          
 615          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2216    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      3      37
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
