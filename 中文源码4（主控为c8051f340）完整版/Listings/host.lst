C51 COMPILER V9.57.0.0   HOST                                                              03/29/2019 19:09:41 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE HOST
OBJECT MODULE PLACED IN .\Objects\host.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE host.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\host.lst) TABS(2) OBJECT(.\Objects\host.obj)

line level    source

   1          /*********************************************************************************************************
             -***********
   2          * 文 件 名：HOST.C
   3          * 功    能：串口相关的功能函数以及设置
   4          *
   5          * 作    者：EMDOOR
   6          * 日    期：2011-9-29
   7          **********************************************************************************************************
             -***********/
   8          #include <C8051F340.h>
   9          #include <hardware.h>
  10          #include <communicate.h>
  11          #include <anticollision.h>
  12          #include <globals.h>
  13          #include <host.h>
  14          #include "intrins.h"
  15          
  16          unsigned char   ENABLE;                             //TRF7960
  17          unsigned char   Firstdata = 1;                      //设置串口同步标志位
  18          /*********************************************************************************************************
             -*********
  19          * 函数名称：PORT_Init()
  20          * 功    能：串口初始化设置函数
  21          * 入口参数：无
  22          * 出口参数：无   
  23          *****************************0.***************************************************************************
             -***********/
  24          void PORT_Init (void)
  25          {  
  26   1         
  27   1         P0MDOUT   = 0x10;
  28   1         XBR0      = 0x01;
  29   1         XBR1      = 0x40;
  30   1      }
  31          
  32          /*********************************************************************************************************
             -*********
  33          * 函数名称：UART0_Init
  34          * 功    能：串口初始化设置函数
  35          * 入口参数：无
  36          * 出口参数：无
  37          * 说    明：该串口初始化函数使用UART0。    
  38          **********************************************************************************************************
             -*********/
  39          void UART0_Init(void)
  40          { 
  41   1          SCON0 = 0x10;   //8位数据位，1位停止位，使能接收                   
  42   1       
  43   1         if (SYSCLK/BAUDRATE/2/256 < 1)
  44   1         {
  45   2            TH1 = -(SYSCLK/BAUDRATE/2);
  46   2            CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx
  47   2            CKCON |=  0x08;
  48   2         } 
C51 COMPILER V9.57.0.0   HOST                                                              03/29/2019 19:09:41 PAGE 2   

  49   1         else if (SYSCLK/BAUDRATE/2/256 < 4)
  50   1         {
  51   2            TH1 = -(SYSCLK/BAUDRATE/2/4);
  52   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01
  53   2            CKCON |=  0x09;
  54   2         }
  55   1         else if (SYSCLK/BAUDRATE/2/256 < 12)
  56   1         {
  57   2            TH1 = -(SYSCLK/BAUDRATE/2/12);
  58   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 00
  59   2         } else
  60   1         {
  61   2            TH1 = -(SYSCLK/BAUDRATE/2/48);
  62   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 10
  63   2            CKCON |=  0x02;
  64   2         }
  65   1      
  66   1         TL1 = TH1;                          // init Timer1
  67   1         TMOD &= ~0xf0;                      // TMOD: timer 1 in 8-bit autoreload
  68   1         TMOD |=  0x20;
  69   1         TR1 = 1;                            // START Timer1
  70   1         TI0 = 1;                            // Indicate TX0 ready
  71   1      }
  72          
  73          
  74          
  75          ///*******************************************************************************************************
             -***********
  76          //* 函数名称：sendchar()
  77          //* 功    能：向计算器上位机发送一个字符函数
  78          //* 入口参数：TXchar    将要被发送的字符
  79          //* 出口参数：无
  80          //* 说    明：无   
  81          //********************************************************************************************************
             -***********/
  82          sendchar(char TXchar)
  83          {
  84   1           
  85   1            if (TXchar == '\n')  {                // check for newline character
  86   2               while (!TI0);                 // wait until UART0 is ready to transmit
  87   2               TI0 = 0;                      // clear interrupt flag
  88   2               SBUF0 = 0x0d;                 // output carriage return command
  89   2            }
  90   1            while (!TI0);                    // wait until UART0 is ready to transmit
  91   1            TI0 = 0;
  92   1            SBUF0 = TXchar;                         // clear interrupt flag
  93   1            return (SBUF0);              // output <c> using UART 0
  94   1      }
  95          
  96          
  97          /*********************************************************************************************************
             -*********
  98          * 函数名称：send_crlf()
  99          * 功    能：向计算器上位机发送一个回车+换行符号
 100          * 入口参数：无
 101          * 出口参数：无
 102          * 说    明：无   
 103          **********************************************************************************************************
             -*********/
 104          void send_crlf(void)
 105          {
 106   1          sendchar('\r');                                 //发送回车符号
C51 COMPILER V9.57.0.0   HOST                                                              03/29/2019 19:09:41 PAGE 3   

 107   1          sendchar('\n');                                 //发送换行符号
 108   1      }
 109          
 110          /*********************************************************************************************************
             -*********
 111          * 函数名称：send_cstring()
 112          * 功    能：向计算器上位机发送一字符串
 113          * 入口参数：*pstr       将要被发送的字符串
 114          * 出口参数：无
 115          * 说    明：无   
 116          **********************************************************************************************************
             -*********/
 117          void send_cstring(char *pstr)
 118          {
 119   1          while(*pstr != '\0')                            //查询是否到达字符串尾
 120   1          {
 121   2              sendchar(*pstr++);                          //发送字符
 122   2          }
 123   1      }
 124          
 125          /*********************************************************************************************************
             -*********
 126          * 函数名称：Nibble2Ascii()
 127          * 功    能：半位字节转化成ASCII十六进制码
 128          * 入口参数：anibble         将要被转换字节
 129          * 出口参数：AsciiOut        转换后的ASCII十六进制码值
 130          * 说    明：无   
 131          **********************************************************************************************************
             -*********/
 132          unsigned char Nibble2Ascii(unsigned char anibble)
 133          {
 134   1          unsigned char AsciiOut = anibble;               //定义转换后的变量AsciiOut，并赋值
 135   1      
 136   1          if(anibble > 9)                                 //如果被转换的半位字节为A-F，则需要加0x07
 137   1              AsciiOut = AsciiOut + 0x07;
 138   1      
 139   1          AsciiOut = AsciiOut + 0x30;                     //其他情况则在转换结果基础上增加偏移量0x30
 140   1      
 141   1          return(AsciiOut);                               //返回转换后的值
 142   1      }
 143          
 144          /*********************************************************************************************************
             -*********
 145          * 函数名称：Put_byte()
 146          * 功    能：发送字节函数半位字节转化成ASCII十六进制码
 147          * 入口参数：abyte         将要被发送字节
 148          * 出口参数：无      
 149          * 说    明：该函数调用两次Nibble2Ascii，将一个字节拆分成高低四位，先转换再次序发送。
 150          **********************************************************************************************************
             -*********/
 151          void send_byte(unsigned char abyte)
 152          {
 153   1          unsigned char temp1, temp2;
 154   1      
 155   1          temp1 = (abyte >> 4) & 0x0F;                    //获取高四位字节
 156   1          temp2 = Nibble2Ascii(temp1);                    //转换成ASCII码
 157   1          sendchar(temp2);                                //发送之
 158   1      
 159   1          temp1 = abyte & 0x0F;                           //获取低四位字节
 160   1          temp2 = Nibble2Ascii(temp1);                    //转换成ASCII码
 161   1          sendchar(temp2);                                //发送之
 162   1      }
C51 COMPILER V9.57.0.0   HOST                                                              03/29/2019 19:09:41 PAGE 4   

 163          /*********************************************************************************************************
             -*********
 164          * 函数名称：Get_nibble()
 165          * 功    能：在发送字节函数Put_byte结束后，获取一个十六进制字节
 166          * 入口参数：无
 167          * 出口参数：rxdata          返回接收到的字节
 168          * 说    明：该函数调用两次Nibble2Ascii，将一个字节拆分成高低四位，先转换再次序发送。
 169          **********************************************************************************************************
             -*********/
 170          unsigned char Get_nibble(void)
 171          {
 172   1          unsigned char reading;                          //读标志位
 173   1          //unsigned char rxdata;
 174   1          reading = 1;                                    //标志位置1 表示读取尚未完成
 175   1          while(reading)                                   //循环读取字符
 176   1          {                       
 177   2              //LPM0; 
 178   2          PCON |= 0x01;               //进入低功耗模式，等待唤醒
 179   2              if(rxdata >= 'a')                           //转换成大写字母
 180   2              {
 181   3                  rxdata -= 32;
 182   3              }
 183   2      
 184   2               /* 如果为十六进制，则回显之 */
 185   2              /*================================================================================================
             -====*/
 186   2              if(((rxdata >= '0') && (rxdata <= '9')) || ((rxdata >= 'A') && (rxdata <= 'F')))
 187   2              {
 188   3                  reading = 0;
 189   3                  sendchar(rxdata);                       //发送回显字符
 190   3              
 191   3                  if(rxdata > '9')                        //如果ASCII码值范围是A-F，则加9
 192   3                  {       
 193   4                      rxdata = (rxdata & 0x0F) + 9;
 194   4                  }
 195   3              }
 196   2              /*================================================================================================
             -====*/
 197   2          }
 198   1          
 199   1          return(rxdata);                                 //返回接收字符                              
 200   1      }
 201          /*********************************************************************************************************
             -*********
 202          * 函数名称：RXhandler()
 203          * 功    能：串口接收中断服务程序
 204          * 入口参数：无
 205          * 出口参数：无
 206          * 说    明：串口USCI_A0接收向量中断
 207          **********************************************************************************************************
             -*********/
 208          void RXhandler (void) interrupt 4
 209          {
 210   1          if(RI0==1)                            //如果串口接收到数据
 211   1          {   
 212   2              RI0=0;                                  
 213   2              rxdata = SBUF0;                         //将接收缓冲区UCA0RXBUF数据赋值给rxdata
 214   2              RXdone = 1;                                 //置起接收标志位
 215   2              if(ENABLE == 0)                            //TRF7960在禁止状态下
 216   2              {
 217   3                  TRFEnable();                             //使能TRF790
 218   3                  //BaudSet(0x00);                          //设置波特率
C51 COMPILER V9.57.0.0   HOST                                                              03/29/2019 19:09:41 PAGE 5   

 219   3                  OSCsel();                           //设置外部晶体振荡器 
 220   3                     
 221   3                  InitialSettings();                     //初始化TRF7960
 222   3                  send_cstring("Reader enabled.");        //向上位机发送信息
 223   3                  ENABLE = 1;                             //设置TRF7960标志位
 224   3              }
 225   2      //       PCON &= ~0X03;                                   //退出idle和stop的状态
 226   2              PCON = 0x00;
 227   2      //        _nop_();
 228   2      //        _nop_();
 229   2      //        _nop_();
 230   2              
 231   2              if(Firstdata)                              //如果是第1次接收到数据
 232   2              {
 233   3                  
 234   3                  IRQOFF();                               //关闭IRQ中断
 235   3                  StopCounter();                            //停止计数器
 236   3               
 237   3                  // /* 利用SP操作，在中断返回后，可调用HostCommands函数 */
 238   3                  // /*-----------------------------------------------------------------------------*/
 239   3                  // asm("mov.w #HostCommands,10(SP)");      //调用HostCommands函数
 240   3                  // /*-----------------------------------------------------------------------------*/
 241   3              }
 242   2          }
 243   1          else
 244   1          {
 245   2               TI0 = 0;                      // clear interrupt flag
 246   2               SBUF0 = 0x0d;                 // output carriage return command
 247   2            }
 248   1      }
*** WARNING C294 IN LINE 51 OF host.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    380    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =      2       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
