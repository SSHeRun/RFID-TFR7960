C51 COMPILER V9.57.0.0   HOST                                                              03/16/2019 22:39:20 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE HOST
OBJECT MODULE PLACED IN .\Objects\host.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE host.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\host.lst) TABS(2) OBJECT(.\Objects\host.obj)

line level    source

   1          /*********************************************************************************************************
             -***********
   2          * 文 件 名：HOST.C
   3          * 功    能：串口相关的功能函数以及设置
   4          *
   5          * 作    者：EMDOOR
   6          * 日    期：2011-9-29
   7          **********************************************************************************************************
             -***********/
   8          #include <C8051F340.h>
   9          #include <hardware.h>
  10          #include <communicate.h>
  11          #include <anticollision.h>
  12          #include <globals.h>
  13          #include <host.h>
  14          
  15          unsigned char   Firstdata = 1;                      //设置串口同步标志位
  16          unsigned char   ENABLE;                             //TRF7960??????????,1??;0????
  17          
  18          
  19          /*********************************************************************************************************
             -*********
  20          * 函数名称：PORT_Init()
  21          * 功    能：串口初始化设置函数
  22          * 入口参数：无
  23          * 出口参数：无   
  24          *****************************0.***************************************************************************
             -***********/
  25          void PORT_Init (void)
  26          {  
  27   1         
  28   1         P0MDOUT   = 0x10;
  29   1         XBR0      = 0x01;
  30   1         XBR1      = 0x40;
  31   1      }
  32          
  33          /*********************************************************************************************************
             -*********
  34          * 函数名称：UART0_Init
  35          * 功    能：串口初始化设置函数
  36          * 入口参数：无
  37          * 出口参数：无
  38          * 说    明：该串口初始化函数使用UART0。    
  39          **********************************************************************************************************
             -*********/
  40          void UART0_Init(void)
  41          { 
  42   1          SCON0 = 0x10;   //8位数据位，1位停止位，使能接收                   
  43   1       
  44   1         if (SYSCLK/BAUDRATE/2/256 < 1)
  45   1         {
  46   2            TH1 = -(SYSCLK/BAUDRATE/2);
  47   2            CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx
  48   2            CKCON |=  0x08;
C51 COMPILER V9.57.0.0   HOST                                                              03/16/2019 22:39:20 PAGE 2   

  49   2         } 
  50   1         else if (SYSCLK/BAUDRATE/2/256 < 4)
  51   1         {
  52   2            TH1 = -(SYSCLK/BAUDRATE/2/4);
  53   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01
  54   2            CKCON |=  0x09;
  55   2         }
  56   1         else if (SYSCLK/BAUDRATE/2/256 < 12)
  57   1         {
  58   2            TH1 = -(SYSCLK/BAUDRATE/2/12);
  59   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 00
  60   2         } else
  61   1         {
  62   2            TH1 = -(SYSCLK/BAUDRATE/2/48);
  63   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 10
  64   2            CKCON |=  0x02;
  65   2         }
  66   1      
  67   1         TL1 = TH1;                          // init Timer1
  68   1         TMOD &= ~0xf0;                      // TMOD: timer 1 in 8-bit autoreload
  69   1         TMOD |=  0x20;
  70   1         TR1 = 1;                            // START Timer1
  71   1         TI0 = 1;                            // Indicate TX0 ready
  72   1      }
  73          
  74          
  75          
  76          ///*******************************************************************************************************
             -***********
  77          //* 函数名称：sendchar()
  78          //* 功    能：向计算器上位机发送一个字符函数
  79          //* 入口参数：TXchar    将要被发送的字符
  80          //* 出口参数：无
  81          //* 说    明：无   
  82          //********************************************************************************************************
             -***********/
  83          sendchar(char TXchar)
  84          {
  85   1           
  86   1            if (TXchar == '\n')  {                // check for newline character
  87   2               while (!TI0);                 // wait until UART0 is ready to transmit
  88   2               TI0 = 0;                      // clear interrupt flag
  89   2               SBUF0 = 0x0d;                 // output carriage return command
  90   2            }
  91   1            while (!TI0);                    // wait until UART0 is ready to transmit
  92   1            TI0 = 0;
  93   1            SBUF0 = TXchar;                         // clear interrupt flag
  94   1            return (SBUF0);              // output <c> using UART 0
  95   1      }
  96          
  97          
  98          /*********************************************************************************************************
             -*********
  99          * 函数名称：send_crlf()
 100          * 功    能：向计算器上位机发送一个回车+换行符号
 101          * 入口参数：无
 102          * 出口参数：无
 103          * 说    明：无   
 104          **********************************************************************************************************
             -*********/
 105          void send_crlf(void)
 106          {
C51 COMPILER V9.57.0.0   HOST                                                              03/16/2019 22:39:20 PAGE 3   

 107   1          sendchar('\r');                                 //发送回车符号
 108   1          sendchar('\n');                                 //发送换行符号
 109   1      }
 110          
 111          /*********************************************************************************************************
             -*********
 112          * 函数名称：send_cstring()
 113          * 功    能：向计算器上位机发送一字符串
 114          * 入口参数：*pstr       将要被发送的字符串
 115          * 出口参数：无
 116          * 说    明：无   
 117          **********************************************************************************************************
             -*********/
 118          void send_cstring(char *pstr)
 119          {
 120   1          while(*pstr != '\0')                            //查询是否到达字符串尾
 121   1          {
 122   2              sendchar(*pstr++);                          //发送字符
 123   2          }
 124   1      }
 125          
 126          /*********************************************************************************************************
             -*********
 127          * 函数名称：Nibble2Ascii()
 128          * 功    能：半位字节转化成ASCII十六进制码
 129          * 入口参数：anibble         将要被转换字节
 130          * 出口参数：AsciiOut        转换后的ASCII十六进制码值
 131          * 说    明：无   
 132          **********************************************************************************************************
             -*********/
 133          unsigned char Nibble2Ascii(unsigned char anibble)
 134          {
 135   1          unsigned char AsciiOut = anibble;               //定义转换后的变量AsciiOut，并赋值
 136   1      
 137   1          if(anibble > 9)                                 //如果被转换的半位字节为A-F，则需要加0x07
 138   1              AsciiOut = AsciiOut + 0x07;
 139   1      
 140   1          AsciiOut = AsciiOut + 0x30;                     //其他情况则在转换结果基础上增加偏移量0x30
 141   1      
 142   1          return(AsciiOut);                               //返回转换后的值
 143   1      }
 144          
 145          /*********************************************************************************************************
             -*********
 146          * 函数名称：Put_byte()
 147          * 功    能：发送字节函数半位字节转化成ASCII十六进制码
 148          * 入口参数：abyte         将要被发送字节
 149          * 出口参数：无      
 150          * 说    明：该函数调用两次Nibble2Ascii，将一个字节拆分成高低四位，先转换再次序发送。
 151          **********************************************************************************************************
             -*********/
 152          void send_byte(unsigned char abyte)
 153          {
 154   1          unsigned char temp1, temp2;
 155   1      
 156   1          temp1 = (abyte >> 4) & 0x0F;                    //获取高四位字节
 157   1          temp2 = Nibble2Ascii(temp1);                    //转换成ASCII码
 158   1          sendchar(temp2);                                //发送之
 159   1      
 160   1          temp1 = abyte & 0x0F;                           //获取低四位字节
 161   1          temp2 = Nibble2Ascii(temp1);                    //转换成ASCII码
 162   1          sendchar(temp2);                                //发送之
C51 COMPILER V9.57.0.0   HOST                                                              03/16/2019 22:39:20 PAGE 4   

 163   1      }
 164          /*********************************************************************************************************
             -*********
 165          * 函数名称：Get_nibble()
 166          * 功    能：在发送字节函数Put_byte结束后，获取一个十六进制字节
 167          * 入口参数：无
 168          * 出口参数：rxdata          返回接收到的字节
 169          * 说    明：该函数调用两次Nibble2Ascii，将一个字节拆分成高低四位，先转换再次序发送。
 170          **********************************************************************************************************
             -*********/
 171          unsigned char Get_nibble(void)
 172          {
 173   1          unsigned char reading;                          //读标志位
 174   1          //unsigned char rxdata;
 175   1          reading = 1;                                    //标志位置1 表示读取尚未完成
 176   1          while(reading)                                   //循环读取字符
 177   1          {                       
 178   2              //LPM0; 
 179   2          PCON |= 0x01;               //进入低功耗模式，等待唤醒
 180   2              if(rxdata >= 'a')                           //转换成大写字母
 181   2              {
 182   3                  rxdata -= 32;
 183   3              }
 184   2      
 185   2               /* 如果为十六进制，则回显之 */
 186   2              /*================================================================================================
             -====*/
 187   2              if(((rxdata >= '0') && (rxdata <= '9')) || ((rxdata >= 'A') && (rxdata <= 'F')))
 188   2              {
 189   3                  reading = 0;
 190   3                  sendchar(rxdata);                       //发送回显字符
 191   3              
 192   3                  if(rxdata > '9')                        //如果ASCII码值范围是A-F，则加9
 193   3                  {       
 194   4                      rxdata = (rxdata & 0x0F) + 9;
 195   4                  }
 196   3              }
 197   2              /*================================================================================================
             -====*/
 198   2          }
 199   1          
 200   1          return(rxdata);                                 //返回接收字符                              
 201   1      }
 202          /*********************************************************************************************************
             -*********
 203          * 函数名称：RXhandler()
 204          * 功    能：串口接收中断服务程序
 205          * 入口参数：无
 206          * 出口参数：无
 207          * 说    明：串口USCI_A0接收向量中断
 208          **********************************************************************************************************
             -*********/
 209          void RXhandler (void) interrupt 4
 210          {
 211   1          if(RI0==1)                            //如果串口接收到数据
 212   1          {   
 213   2              RI0=0;                                  
 214   2              rxdata = SBUF0;                         //将接收缓冲区UCA0RXBUF数据赋值给rxdata
 215   2              RXdone = 1;                                 //置起接收标志位
 216   2              if(ENABLE == 0)                            //TRF7960在禁止状态下
 217   2              {
 218   3                  TRFEnable();                             //使能TRF790
C51 COMPILER V9.57.0.0   HOST                                                              03/16/2019 22:39:20 PAGE 5   

 219   3                  //BaudSet(0x00);                          //设置波特率
 220   3                  OSCsel();                           //设置外部晶体振荡器 
 221   3                     
 222   3                  InitialSettings();                     //初始化TRF7960
 223   3                  send_cstring("Reader enabled.");        //向上位机发送信息
 224   3                  ENABLE = 1;                             //设置TRF7960标志位
 225   3              }
 226   2             PCON &= ~0X03;                                   //退出idle和stop的状态
 227   2      
 228   2              if(Firstdata)                              //如果是第1次接收到数据
 229   2              {
 230   3                  
 231   3                  IRQOFF();                               //关闭IRQ中断
 232   3                  StopCounter();                            //停止计数器
 233   3               
 234   3                  // /* 利用SP操作，在中断返回后，可调用HostCommands函数 */
 235   3                  // /*-----------------------------------------------------------------------------*/
 236   3                  // asm("mov.w #HostCommands,10(SP)");      //调用HostCommands函数
 237   3                  // /*-----------------------------------------------------------------------------*/
 238   3              }
 239   2          }
 240   1          else
 241   1          {
 242   2               TI0 = 0;                      // clear interrupt flag
 243   2               SBUF0 = 0x0d;                 // output carriage return command
 244   2            }
 245   1      }
*** WARNING C294 IN LINE 52 OF host.c: unreachable code


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    380    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =      2       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
