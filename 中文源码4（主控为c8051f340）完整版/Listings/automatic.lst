C51 COMPILER V9.57.0.0   AUTOMATIC                                                         04/03/2019 19:21:51 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE AUTOMATIC
OBJECT MODULE PLACED IN .\Objects\automatic.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE automatic.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\automatic.lst) TABS(2) OBJECT(.\Objects\automatic.obj)

line level    source

   1          /*********************************************************************************************************
             -*********
   2          * ÎÄ ¼þ Ãû£ºAUTOMATIC.C
   3          * ¹¦    ÄÜ£ºÕì²âÔÄ¶ÁÆ÷ÔÄ¶Á·¶Î§ÄÚµÄËùÓÐ¾í±ê¿¨Æ¬¡£
   4          *
   5          * ×÷    Õß£ºEMDOOR
   6          * ÈÕ    ÆÚ£º2011-9-29
   7          **********************************************************************************************************
             -**********/
   8          #include <automatic.h>
   9          
  10          unsigned char Set_pro[9]={0x0C,0x00,0x03,0x04,0x10,0x00,0x21,0x01,0x00};                    //ÉèÖÃ²ÎÊýÊý¾Ý
  11          unsigned char Write_Sig[12]={0x0F,0x00,0x03,0x04,0x18,0x00,0x21,0x08,0xFF,0xFF};          //Ð´¿éµØÖ·0x01 Ê
             -ý¾Ý12345678
  12          unsigned char Read_Sig[8]={0x0B,0x00,0x03,0x04,0x18,0x00,0x20,0x08};                         //Ð´¿éµØÖ·0x0
             -1
  13          //unsigned char Write_AFI[8]={0x0B,0x00,0x03,0x04,0x18,0x00,0x27,0x01};                       //Ð´AFIÊý¾Ý0
             -1
  14          //unsigned char Write_DSFID[8]={0x0B,0x00,0x03,0x04,0x18,0x40,0x29,0xEE};                      //Ð´DSFIDÊý
             -¾ÝEE
  15          //unsigned char Get_info[7]={0x0A,0x00,0x03,0x04,0x18,0x00,0x2B};                             //»ñÈ¡¿¨Æ¬Ïµ
             -Í³ÐÅÏ¢
  16          //unsigned char Get_sec[9]={0x0C,0x00,0x03,0x04,0x18,0x00,0x2C,0x01,0x01};                   //»ñÈ¡¿é°²È«×
             -´Ì¬µØÖ·0x01,¿éÊýÁ¿02£¨Êµ¼ÊÎª3¸ö¿é£©
  17          
  18          /*********************************************************************************************************
             -*********
  19          * º¯ÊýÃû³Æ£ºRFID_Test()
  20          * ¹¦    ÄÜ£ºRFID¿¨Æ¬ÍÑ»ú²âÊÔº¯Êý¡£
  21          * Èë¿Ú²ÎÊý£ºÎÞ
  22          * ³ö¿Ú²ÎÊý£ºÎÞ
  23          * Ëµ    Ã÷£º¸Ãº¯ÊýÄÜ¶Ô¿¨Æ¬½øÐÐ¶ÁÐ´²Ù×÷¡¢¼°Ð´AFI¡¢Ð´DSFID¡¢ºÍ»ñÈ¡¿¨Æ¬ÐÅÏ¢ÐÅÏ¢µÈ²Ù×÷    
  24          **********************************************************************************************************
             -*********/
  25          void RFID_test(void)
  26          {
  27   1          unsigned char i,count;   
  28   1      
  29   1            for(i = 0; i < 9; i++)                      //ÉèÖÃTRF7961Í¨ÐÅ²ÎÊý
  30   1            {
  31   2                buf[i]=Set_pro[i];
  32   2            }
  33   1            
  34   1            count = buf[0] - 8;
  35   1            WriteSingle(&buf[5], count);
  36   1            
  37   1            // delay_ms(800);
  38   1      
  39   1            // for(i = 0; i < 12; i++)             //Ð´Ò»¸ö¿éµØÖ·Îª0x01 12345678
  40   1            // {
  41   1            //     buf[ i ] = Write_Sig[ i ];
  42   1            // }
  43   1            
  44   1            for(i = 0; i < 9; i++)              //¶ÁÒ»¸ö¿éµØÖ·Îª0x01
C51 COMPILER V9.57.0.0   AUTOMATIC                                                         04/03/2019 19:21:51 PAGE 2   

  45   1            {
  46   2                buf[ i ] = Read_Sig[ i ];
  47   2            }
  48   1        
  49   1            // for(i = 0; i < 8; i++)              //Ð´AFIÓ¦ÓÃ×å
  50   1            // {
  51   1            //     buf[ i ] = Write_AFI[ i ];
  52   1            // }
  53   1       
  54   1            // for(i = 0; i < 8; i++)              //Ð´DSFIDÊý¾Ý´æ´¢¸ñÊ½
  55   1            // {
  56   1            //     buf[i]=Write_DSFID[i];
  57   1            // }
  58   1         
  59   1            // for(i = 0; i < 7; i++)              //»ñÈ¡¿¨Æ¬ÐÅÏ¢ÐÅÏ¢
  60   1            // {
  61   1            //     buf[ i ] = Get_info[ i ];
  62   1            // }
  63   1                
  64   1            // for(i = 0; i < 9; i++)              //»ñÈ¡¿é°²È«×´Ì¬   
  65   1            // {
  66   1            //     buf[ i ] = Get_sec[ i ];
  67   1            //  }
  68   1            
  69   1            count=buf[0]-8;
  70   1            RequestCommand(buf,count,0x00,0);//·¢ËÍÇëÇóÃüÁî  
  71   1      
  72   1            
  73   1            //delay_ms(800);
  74   1      }
  75          
  76          
  77          /*********************************************************************************************************
             -*********
  78          * º¯ÊýÃû³Æ£ºFindTags()
  79          * ¹¦    ÄÜ£º¸ù¾ÝÖ¸¶¨¾í±êÐ­ÒéÀàÐÍ£¬ÉèÖÃTRF7960ÅäÖÃ¸÷Ïà¹Ø¼Ä´æÆ÷ºó£¬½øÐÐÑ°¿¨²Ù×÷¡£
  80          * Èë¿Ú²ÎÊý£ºprotocol       Ö¸¶¨Ð­ÒéÀàÐÍ
  81          * ³ö¿Ú²ÎÊý£ºÎÞ
  82          * Ëµ    Ã÷£º¸Ãº¯ÊýÊÇÒ»¸öËÀÑ­»·º¯Êý£¬ËùÓÐµÄÍÑ»úÑÝÊ¾Ö´ÐÐ¹ý³Ì¾ùÔÚ´ËÍê³É¡£
  83          **********************************************************************************************************
             -*********/
  84          void FindTags(void)
  85          {
  86   1          unsigned char command[10];                      //¶¨ÒåÃüÁîÊý¾ÝÔÝ´æ»º³åÆ÷Êý×é
  87   1          unsigned char i, count;
  88   1        while(1)
  89   1        {
  90   2                command[0] = ChipStateControl;          // ¿ªÆôRFÊ¹ÄÜ£¬Ñ¡Ôñ5V²Ù×÷Ä£Ê½
  91   2                command[1] = 0x21;
  92   2                command[2] = ISOControl;                // ÉèÖÃÑ¡ÔñISO15693²Ù×÷Ä£Ê½Îª:¸ß±ÈÌØÂÊ26.48kbps µ¥·ùÔØ²¨ 1/4(
             -Ä¬ÈÏÄ£Ê½)
  93   2                command[3] = 0x02;
  94   2                WriteSingle(command, 4);                 // Ð´4¸ö×Ö½ÚÃüÁîµ½TRF7960¼Ä´æÆ÷ÖÐ
  95   2      
  96   2                delay_ms(5);
  97   2                flags = 0x06;                            // 16(slot)²ÛÄ£Ê½
  98   2                //flags = 0x26;                          // 1(slot)²ÛÄ£Ê½
  99   2      
 100   2                command[0] = 0x04;
 101   2                
 102   2                InventoryRequest(command, 0);          // ·¢ËÍ×ÜÁ¿ÇëÇóÃüÁî(¼´Ñ°¿¨ÃüÁî)      
 103   2      
C51 COMPILER V9.57.0.0   AUTOMATIC                                                         04/03/2019 19:21:51 PAGE 3   

 104   2                command[0] = ChipStateControl;          // ¹Ø±ÕRF²¿·ÖµçÂ·
 105   2                command[1] = 0x01;
 106   2                WriteSingle(command, 2);
 107   2                delay_ms(1);
 108   2      
 109   2                command[0] = IRQStatus;                // ¸ø¼Ä´æÆ÷¸³Öµ
 110   2                command[1] = IRQMask;               
 111   2      
 112   2                                          
 113   2                ReadCont(command, 2);                 //¶ÁÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷¼°ÖÐ¶Ï±êÖ¾
 114   2      
 115   2                RFID_test();
 116   2        
 117   2        
 118   2            delay_ms(10);
 119   2        }   /* while */
 120   1      //  
 121   1      //    while(1)                                         //ISO14443AÐ­Òé±ê×¼
 122   1      //    {
 123   1      //            command[0] = ChipStateControl;           // ¿ªÆôRFÊ¹ÄÜ£¬Ñ¡Ôñ5V²Ù×÷Ä£Ê½
 124   1      //            command[1] = 0x21;
 125   1      //            command[2] = ISOControl;                 // ÉèÖÃÑ¡ÔñISO14443A²Ù×÷Ä£Ê½Îª:±ÈÌØÂÊ106kbps
 126   1      //            command[3] = 0x08;
 127   1      //            WriteSingle(command, 4);
 128   1      //            delay_ms(5);
 129   1      //            
 130   1      //            AnticollisionSequenceA(0x01);           //Ö´ÐÐISO14443AÍêÕû·Â³å×²ÐòÁÐ
 131   1      //            
 132   1      //            command[0] = ChipStateControl;          // ¸ø¼Ä´æÆ÷¸³Öµ
 133   1      //            command[1] = 0x01;
 134   1      //            WriteSingle(command, 2);                 // ¹Ø±ÕRF²¿·ÖµçÂ· 
 135   1      //            delay_ms(1);
 136   1      
 137   1      //            command[0] = IRQStatus;                  // ¸ø¼Ä´æÆ÷¸³Öµ 
 138   1      //            command[1] = IRQMask;   
 139   1      //        
 140   1      ////            if(SPIMODE)
 141   1      //                ReadCont(command, 2);             //¶ÁÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷¼°ÖÐ¶Ï±êÖ¾
 142   1      ////            else
 143   1      ////                ReadSingle(command, 1); 
 144   1      //    }
 145   1      
 146   1      
 147   1      //      while(1)                                        //ISO14443BÐ­Òé±ê×¼
 148   1      //      {
 149   1      //            command[0] = ChipStateControl;
 150   1      //            command[1] = 0x21;                     // ¿ªÆôRFÊ¹ÄÜ£¬Ñ¡Ôñ5V²Ù×÷Ä£Ê½
 151   1      //            WriteSingle(command, 2);
 152   1      //        
 153   1      //            //command[0] = ISOControl;                // ÉèÖÃÑ¡ÔñISO14443B²Ù×÷Ä£Ê½Îª:±ÈÌØÂÊ106kbps
 154   1      //            command[1] = 0x0C;
 155   1      //            WriteSingle(command, 2);
 156   1      
 157   1      //            delay_ms(5);
 158   1      //            AnticollisionSequenceB(0xB0, 0x04);     //Ö´ÐÐISO14443AÍêÕû·Â³å×²ÐòÁÐ(0x04±íÊ¾16²Ûslots)
 159   1      //            //AnticollisionSequenceB(0xB0, 0x00);  //0x00 ±íÊ¾µ¥¸ö²Ûslot
 160   1      
 161   1      //            command[0] = ChipStateControl;  
 162   1      //            command[1] = 0x01;
 163   1      //            WriteSingle(command, 2);               // ¹Ø±ÕRF²¿·ÖµçÂ· 
 164   1      //            delay_ms(1);
 165   1      
C51 COMPILER V9.57.0.0   AUTOMATIC                                                         04/03/2019 19:21:51 PAGE 4   

 166   1      //            command[0] = IRQStatus;
 167   1      //            command[1] = IRQMask;   
 168   1      //        
 169   1      ////            if(SPIMODE)                            //¶ÁÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷¼°ÖÐ¶Ï±êÖ¾
 170   1      //                ReadCont(command, 2);
 171   1      ////            else
 172   1      ////                ReadSingle(command, 1); 
 173   1      //      }
 174   1            // while(1){
 175   1            //    command[0] = ChipStateControl;          // ¿ªÆôRFÊ¹ÄÜ£¬Ñ¡Ôñ5V²Ù×÷Ä£Ê½
 176   1            //       command[1] = 0x21;
 177   1            //       command[2] = ISOControl;                // ÉèÖÃÑ¡ÔñTag-it²Ù×÷Ä£Ê½
 178   1            //       command[3] = 0x13;
 179   1            //       WriteSingle(command, 4);
 180   1            //       delay_ms(5);
 181   1            //       flags = 0x00;
 182   1            //       command[0] = 0x00;
 183   1            //       TIInventoryRequest(command, 0);         //·¢ËÍÑ°¿¨ÃüÁî
 184   1      
 185   1            //       command[0] = ChipStateControl;          // ¹Ø±ÕRF²¿·ÖµçÂ· 
 186   1            //       command[1] = 0x01;
 187   1            //       WriteSingle(command, 2);
 188   1            //       delay_ms(1);
 189   1      
 190   1            //       command[0] = IRQStatus;                 // ¸ø¼Ä´æÆ÷¸³Öµ 
 191   1            //       command[1] = IRQMask;
 192   1              
 193   1            //       if(SPIMODE)
 194   1            //           ReadCont(command, 2);               //¶ÁÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷¼°ÖÐ¶Ï±êÖ¾
 195   1            //       else
 196   1            //           ReadSingle(command, 1); 
 197   1            // }
 198   1      }   /* FindTags */
*** WARNING C280 IN LINE 87 OF automatic.c: 'i': unreferenced local variable
*** WARNING C280 IN LINE 87 OF automatic.c: 'count': unreferenced local variable


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    225    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     29      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
