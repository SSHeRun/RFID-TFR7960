C51 COMPILER V9.57.0.0   AUTOMATIC                                                         03/04/2019 20:44:07 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE AUTOMATIC
OBJECT MODULE PLACED IN .\Objects\automatic.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE automatic.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\automatic.lst) TABS(2) OBJECT(.\Objects\automatic.obj)

line level    source

   1          /*********************************************************************************************************
             -*********
   2          * 文 件 名：AUTOMATIC.C
   3          * 功    能：侦测阅读器阅读范围内的所有卷标卡片。
   4          *
   5          * 作    者：EMDOOR
   6          * 日    期：2011-9-29
   7          **********************************************************************************************************
             -**********/
   8          #include <automatic.h>
   9          
  10          unsigned char Set_pro[9]={0x0C,0x00,0x03,0x04,0x10,0x00,0x21,0x01,0x00};                    //??????
  11          unsigned char Write_Sig[12]={0x0F,0x00,0x03,0x04,0x18,0x00,0x21,0x08,0xFF,0xFF};  //????0x01 ??12345678
  12          unsigned char Read_Sig[8]={0x0B,0x00,0x03,0x04,0x18,0x00,0x20,0x08};                        //????0x01
  13          //unsigned char Write_AFI[8]={0x0B,0x00,0x03,0x04,0x18,0x00,0x27,0x01};                       //?AFI??01
  14          //unsigned char Write_DSFID[8]={0x0B,0x00,0x03,0x04,0x18,0x40,0x29,0xEE};                     //?DSFID??EE
  15          //unsigned char Get_info[7]={0x0A,0x00,0x03,0x04,0x18,0x00,0x2B};                             //????????
  16          //unsigned char Get_sec[9]={0x0C,0x00,0x03,0x04,0x18,0x00,0x2C,0x01,0x01};                    //?????????0
             -x01,???02(???3??)
  17          
  18          /*********************************************************************************************************
             -*********
  19          * 函数名称：FindTags()
  20          * 功    能：根据指定卷标协议类型，设置TRF7960配置各相关寄存器后，进行寻卡操作。
  21          * 入口参数：protocol       指定协议类型
  22          * 出口参数：无
  23          * 说    明：该函数是一个死循环函数，所有的脱机演示执行过程均在此完成。
  24          **********************************************************************************************************
             -*********/
  25          void FindTags(void)
  26          {
  27   1          unsigned char command[10];                      //定义命令数据暂存缓冲器数组
  28   1          unsigned char i, count;
  29   1      //    while(1)
  30   1      //    {
  31   1      //            command[0] = ChipStateControl;          // ??RF??,??5V????
  32   1      //            command[1] = 0x21;
  33   1      //            command[2] = ISOControl;                // ????ISO15693?????:????26.48kbps ???? 1/4(????)
  34   1      //            command[3] = 0x02;
  35   1      //            WriteSingle(command, 4);                // ?4??????TRF7960????
  36   1      
  37   1      //            delay_ms(5);
  38   1      //            flags = 0x06;                           // 16(slot)???
  39   1      //            //flags = 0x26;
  40   1      
  41   1      //            command[0] = 0x04;
  42   1      //            
  43   1      //            count = buf[0] - 9;
  44   1      //            InventoryRequest(command, 0);           // ????????(?????)      
  45   1      
  46   1      //            command[0] = ChipStateControl;          // ??RF????
  47   1      //            command[1] = 0x01;
  48   1      //            WriteSingle(command, 2);
  49   1      //            delay_ms(1);
C51 COMPILER V9.57.0.0   AUTOMATIC                                                         03/04/2019 20:44:07 PAGE 2   

  50   1      
  51   1      //            command[0] = IRQStatus;                 // ??????
  52   1      //            command[1] = IRQMask;               
  53   1      
  54   1      //                                      
  55   1      //        ReadCont(command, 2);                //??IRQ????????????
  56   1      //    
  57   1      //        delay_ms(10);
  58   1      //    }   /* while */
  59   1        
  60   1      //    while(1)
  61   1      //    {
  62   1      //            command[0] = ChipStateControl;          // ??RF??,??5V????
  63   1      //            command[1] = 0x21;
  64   1      //            command[2] = ISOControl;                // ????ISO14443A?????:???106kbps
  65   1      //            command[3] = 0x08;
  66   1      //            WriteSingle(command, 4);
  67   1      //            delay_ms(5);
  68   1      //            
  69   1      //            AnticollisionSequenceA(0x00);           //??ISO14443A???????
  70   1      //            
  71   1      //            command[0] = ChipStateControl;          // ??????
  72   1      //            command[1] = 0x01;
  73   1      //            WriteSingle(command, 2);                // ??RF???? 
  74   1      //            delay_ms(1);
  75   1      
  76   1      //            command[0] = IRQStatus;                 // ?????? 
  77   1      //            command[1] = IRQMask;   
  78   1      //        
  79   1      ////            if(SPIMODE)
  80   1      //                ReadCont(command, 2);               //??IRQ????????????
  81   1      ////            else
  82   1      ////                ReadSingle(command, 1); 
  83   1      //    }
  84   1      
  85   1      
  86   1            while(1)
  87   1            {
  88   2                  command[0] = ChipStateControl;
  89   2                  command[1] = 0x21;                      // ??RF??,??5V????
  90   2                  WriteSingle(command, 2);
  91   2              
  92   2                  command[0] = ISOControl;                // ????ISO14443B?????:???106kbps
  93   2                  command[1] = 0x0C;
  94   2                  WriteSingle(command, 2);
  95   2      
  96   2                  delay_ms(5);
  97   2                  AnticollisionSequenceB(0xB1, 0x04);     //??ISO14443A???????(0x04??16?slots)
  98   2                  //AnticollisionSequenceB(0xB0, 0x00);   //0x00 ?????slot
  99   2      
 100   2                  command[0] = ChipStateControl;  
 101   2                  command[1] = 0x01;
 102   2                  WriteSingle(command, 2);                // ??RF???? 
 103   2                  delay_ms(1);
 104   2      
 105   2                  command[0] = IRQStatus;
 106   2                  command[1] = IRQMask;   
 107   2              
 108   2      //            if(SPIMODE)                             //??IRQ????????????
 109   2                      ReadCont(command, 2);
 110   2      //            else
 111   2      //                ReadSingle(command, 1); 
C51 COMPILER V9.57.0.0   AUTOMATIC                                                         03/04/2019 20:44:07 PAGE 3   

 112   2            }
 113   1      }   /* FindTags */
*** WARNING C280 IN LINE 28 OF automatic.c: 'i': unreferenced local variable
*** WARNING C280 IN LINE 28 OF automatic.c: 'count': unreferenced local variable
 114          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    102    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     29      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
