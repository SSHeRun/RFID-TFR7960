C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE COMMUNICATE
OBJECT MODULE PLACED IN .\Objects\communicate.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE communicate.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\communicate.lst) TABS(2) OBJECT(.\Objects\communicate.obj)

line level    source

   1          /********************************************************************************************************
   2          * ÎÄ ¼þ Ãû£ºCOMMUNICATE.H
   3          * ¹¦    ÄÜ£ºRFIDÔÄ¶ÁÆ÷TRF7960ÓëC8051F340Î¢¿ØÖÆÆ÷Ö®¼äÍ¨ÐÅ·½Ê½Í·ÎÄ¼þ¡£
   4          * Ó²¼þÁ¬½Ó£ºC8051F340ÓëTRF7960Ö®¼äÍ¨ÐÅÓ²¼þÁ¬½Ó¹ØÏµÈçÏÂËùÊ¾£º
   5          *                C8051F340                 TRF7960
   6          *********************    PARALLEL INTERFACE    ******************************************         
   7          *               P0.7           IRQ
   8          *         P0.3                 Slave_select
   9          *               P0.2                 SIMO
  10          *               P0.1                 SOMI
  11          *               P0.0                 DATA_CLK
  12          *       P4.0             MOD
  13          *       P4.2         ASK/OOK
  14          *       P4.3         EN
  15          *
  16          * °æ    ±¾£ºV1.0
  17          * ×÷    Õß£ºEMDOOR
  18          * ÈÕ    ÆÚ£º2011-9-29
  19          *********************************************************************************************************/
  20          #include <communicate.h>
  21          #include <globals.h>
  22          #include <hardware.h>
  23          #include <c8051f340.h>
  24          #define DBG  0
  25          static unsigned char temp;
  26          static unsigned int mask = 0x80;
  27          
  28          /*********************************************************************************************************
             -*********
  29          * º¯ÊýÃû³Æ£ºWriteSingle()
  30          * ¹¦    ÄÜ£ºÐ´µ¥¸ö¼Ä´æÆ÷»òÕßÌØÊâµØÖ·µÄ¶à¸ö¼Ä´æÆ÷ÃüÁî
  31          * Èë¿Ú²ÎÊý£º*pbuf            ½«ÒªÐ´ÈëµÄÊý¾Ý           
  32          *           lenght           Ð´ÈëÊý¾ÝµÄ³¤¶È 
  33          * ³ö¿Ú²ÎÊý£ºÎÞ
  34          * Ëµ    Ã÷£ºÐ´ÃüÁî¡£
  35          **********************************************************************************************************
             -********/
  36          void WriteSingle(unsigned char *pbuf, unsigned char lenght)
  37          {
  38   1        unsigned char i,j;
  39   1          /*  SPI Î»Ä£Ê½ */
  40   1              /*-----------------------------------------------------------------------------*/
  41   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
  42   1              CLKOFF();                                   //CLKÊ±ÖÓ¹Ø±Õ£¨µÍ£©
  43   1              while(lenght > 0)
  44   1              {
  45   2                  *pbuf = (0x1f & *pbuf);                 //È¡µÍ5Î»B0-B4 ¼Ä´æÆ÷µØÖ·Êý¾Ý ¸ñÊ½Îª000XXXXX
  46   2                  for(i = 0; i < 2; i++)                  //ÒÔµ¥¸ö¼Ä´æÆ÷£¬ÏÈ·¢ËÍµØÖ·£¬ÔÙ·¢ËÍÊý¾Ý»òÃüÁî
  47   2                  {
  48   3                      for(j = 0; j < 8; j++)
  49   3                      {
  50   4                          if (*pbuf & mask)               //ÉèÖÃÊý¾ÝÎ»
  51   4                              SIMOON();
  52   4                          else
C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 2   

  53   4                              SIMOOFF();
  54   4                         
  55   4                          CLKON();                        //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
  56   4                          CLKOFF();
  57   4                          mask >>= 1;                     //±êÖ¾Î»ÓÒÒÆ
  58   4                      }   /* for */
  59   3                      mask = 0x80;
  60   3                      pbuf++;
  61   3                      lenght--;
  62   3                  }/*for*/
  63   2              } /*while*/
  64   1      
  65   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
  66   1              /*-----------------------------------------------------------------------------*/
  67   1      }   /* WriteSingle */
  68          
  69          /*********************************************************************************************************
             -*********
  70          * ????:WriteCont()
  71          * ?    ?:????????????????????
  72          * ????:*pbuf            ???????           
  73          *           lenght           ??????? 
  74          * ????:?
  75          * ?    ?:????????
  76          **********************************************************************************************************
             -********/
  77          void WriteCont(unsigned char *pbuf, unsigned char lenght)
  78          {
  79   1          
  80   1          unsigned char j;
  81   1           
  82   1          /*====================================================================================================
             -*/     
  83   1          /* ??(SPI)???? */
  84   1          /*====================================================================================================
             -*/
  85   1          /*-----------------------------------------------------------------------------*/
  86   1          /*  SPI ??? */
  87   1          /*-----------------------------------------------------------------------------*/
  88   1          L_SlaveSelect();                            //SS?????,SPI??
  89   1          CLKOFF();                                   //CLK????(?)
  90   1      
  91   1          *pbuf = (0x20 | *pbuf);                     //??B5 ??????? ????? ???001XXXXX
  92   1          *pbuf = (0x3f &*pbuf);                      //??6?B0-B5 ???????
  93   1          while(lenght > 0)
  94   1          {
  95   2              for(j=0;j<8;j++)
  96   2              {
  97   3                  if (*pbuf & mask)                   //?????
  98   3                      SIMOON();
  99   3                  else
 100   3                      SIMOOFF();
 101   3      
 102   3                  CLKON();                            //??CLK????,????
 103   3                  CLKOFF();
 104   3                  mask >>= 1;                         //?????
 105   3              }/*for*/
 106   2      
 107   2              mask = 0x80;                            
 108   2              pbuf++;
 109   2              lenght--;
 110   2          }/*while*/
C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 3   

 111   1      
 112   1          H_SlaveSelect();                            //SS?????,SPI??
 113   1          /*-----------------------------------------------------------------------------*/
 114   1      }   /* WriteCont */
 115          
 116          /*********************************************************************************************************
             -*********
 117          * º¯ÊýÃû³Æ£ºReadSingle()
 118          * ¹¦    ÄÜ£º¶Áµ¥¸ö¼Ä´æÆ÷
 119          * Èë¿Ú²ÎÊý£º*pbuf            ½«Òª¶ÁÈ¡µÄÊý¾Ý           
 120          *           lenght           ¶ÁÈ¡Êý¾ÝµÄ³¤¶È 
 121          * ³ö¿Ú²ÎÊý£ºÎÞ
 122          * Ëµ    Ã÷£ºÎÞ
 123          **********************************************************************************************************
             -********/
 124          void ReadSingle(unsigned char *pbuf, unsigned char lenght)
 125          {
 126   1       unsigned char j;
 127   1           /*  SPI Î»Ä£Ê½ */
 128   1              /*-----------------------------------------------------------------------------*/
 129   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
 130   1      
 131   1              while(lenght > 0)
 132   1              {
 133   2                  *pbuf = (0x40 | *pbuf);                 //È¡Î»B6 ¼Ä´æÆ÷µØÖ·Êý¾Ý µ¥¸ö±êÖ¾Î» ¸ñÊ½Îª01XXXXXX
 134   2                  *pbuf = (0x5f &*pbuf);                  //È¡µÍ7Î»B0-B6 ¼Ä´æÆ÷µØÖ·Êý¾Ý
 135   2                  for(j = 0; j < 8; j++)
 136   2                  {
 137   3                      if (*pbuf & mask)                   //ÉèÖÃÊý¾ÝÎ»
 138   3                          SIMOON();
 139   3                      else
 140   3                          SIMOOFF();
 141   3                      
 142   3                      CLKON();                            //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 143   3                      CLKOFF();
 144   3                      mask >>= 1;                         //±êÖ¾Î»ÓÒÒÆ
 145   3                  }   /* for */
 146   2                  mask = 0x80;
 147   2      
 148   2                  *pbuf = 0;                              //¿ªÊ¼¶ÁÈ¡´¦Àí
 149   2                  for(j = 0; j < 8; j++)
 150   2                  {
 151   3                      *pbuf <<= 1;                        //Êý¾Ý×óÒÆ
 152   3                      CLKON();                            //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 153   3                      CLKOFF();
 154   3      
 155   3                      if (SOMISIGNAL)                     //ÅÐ¶ÏSOMIÒý½Å
 156   3                          *pbuf |= 1;                     //ÈôÎª¸ßµçÆ½£¬Ôò½«Êý¾Ý»òÉÏ 1
 157   3                  }   /* for */
 158   2      
 159   2                  pbuf++;
 160   2                  lenght--;
 161   2              } /* while */
 162   1      
 163   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
 164   1              /*-----------------------------------------------------------------------------*/
 165   1      }   /* ReadCont */
 166          
 167          /*********************************************************************************************************
             -*********
 168          * º¯ÊýÃû³Æ£ºReadCont()
 169          * ¹¦    ÄÜ£ºÁ¬Ðø¶Á¼Ä´æÆ÷»òÕßÌØÊâµØÖ·µÄ¶à¸ö¼Ä´æÆ÷ÃüÁî
C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 4   

 170          * Èë¿Ú²ÎÊý£º*pbuf            ½«Òª¶ÁÈ¡µÄÊý¾Ý           
 171          *           lenght           ¶ÁÈ¡Êý¾ÝµÄ³¤¶È 
 172          * ³ö¿Ú²ÎÊý£ºÎÞ
 173          * Ëµ    Ã÷£ºÁ¬ÐøµØÖ·Ð´ÃüÁî¡£
 174          **********************************************************************************************************
             -********/
 175          void ReadCont(unsigned char *pbuf, unsigned char lenght)
 176          {
 177   1          unsigned char j;
 178   1        /*  SPI Î»Ä£Ê½ */
 179   1              /*-----------------------------------------------------------------------------*/
 180   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
 181   1              *pbuf = (0x60 | *pbuf);                     //È¡Î»B6B5 ¼Ä´æÆ÷µØÖ·Êý¾Ý µ¥¸ö±êÖ¾Î» ¸ñÊ½Îª011XXXXX
 182   1              *pbuf = (0x7f & *pbuf);                     //È¡µÍ7Î»B0-B6 ¼Ä´æÆ÷µØÖ·Êý¾Ý
 183   1      
 184   1              for(j = 0; j < 8; j++)                      //Ð´¼Ä´æÆ÷µØÖ·
 185   1              {
 186   2                  if (*pbuf & mask)                       //ÉèÖÃÊý¾ÝÎ»
 187   2                      SIMOON();
 188   2                  else
 189   2                      SIMOOFF();
 190   2           
 191   2                  CLKON();                                //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 192   2                  CLKOFF();
 193   2                  mask >>= 1;                             //±êÖ¾Î»ÓÒÒÆ
 194   2              }/*for*/
 195   1              mask = 0x80;
 196   1      
 197   1              while(lenght > 0)                           //¿ªÊ¼¶ÁÈ¡´¦Àí
 198   1              {
 199   2                  *pbuf = 0;                              //Çå¿Õ»º³åÇø
 200   2                  for(j = 0; j < 8; j++)
 201   2                  {
 202   3                      *pbuf <<= 1;                        //Êý¾Ý×óÒÆ
 203   3                      CLKON();                            //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 204   3                      CLKOFF();
 205   3                      if (SOMISIGNAL)
 206   3                      *pbuf |= 1;
 207   3                  }/*for*/
 208   2      
 209   2                  pbuf++;                                 //¶Á½áÊø´¦Àí
 210   2                  lenght--;
 211   2              }/* while */
 212   1      
 213   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
 214   1          
 215   1      }
 216          
 217          /*********************************************************************************************************
             -*********
 218          * º¯ÊýÃû³Æ£ºDirectCommand()
 219          * ¹¦    ÄÜ£ºÖ±½ÓÃüÁî¿É·¢ËÍÒ»¸öÃüÁîµ½ÔÄ¶ÁÆ÷Ð¾Æ¬
 220          * Èë¿Ú²ÎÊý£º*pbuf            ½«Òª·¢ËÍµÄÃüÁîÊý¾Ý           
 221          * ³ö¿Ú²ÎÊý£ºÎÞ
 222          * Ëµ    Ã÷£ºÖ±½ÓÃüÁî¡£
 223          **********************************************************************************************************
             -********/
 224          void DirectCommand(unsigned char *pbuf)
 225          {
 226   1        unsigned char j;
 227   1        /*  SPI Î»Ä£Ê½ */
 228   1              /*-----------------------------------------------------------------------------*/
C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 5   

 229   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
 230   1              *pbuf = (0x80 | *pbuf);                     //È¡Î»B7 ¼Ä´æÆ÷µØÖ·Êý¾Ý ÃüÁî±êÖ¾Î» ¸ñÊ½Îª1XXXXXXX
 231   1              *pbuf = (0x9f & *pbuf);                     //ÃüÁîÖµ
 232   1      
 233   1              for(j = 0; j < 8; j++)                      //Ð´¼Ä´æÆ÷µØÖ·
 234   1              {
 235   2                  if (*pbuf & mask)                       //ÉèÖÃÊý¾ÝÎ»
 236   2                      SIMOON();
 237   2                  else
 238   2                      SIMOOFF();
 239   2      
 240   2                  CLKON();                                //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 241   2                  CLKOFF();
 242   2                  mask >>= 1;                             //±êÖ¾Î»ÓÒÒÆ
 243   2              }   /* for */
 244   1              mask = 0x80;
 245   1      
 246   1              CLKON();                                    //Ôö¼Ó¶îÍâÊ±ÖÓÂö³å
 247   1              CLKOFF();
 248   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
 249   1              /*-----------------------------------------------------------------------------*/
 250   1      
 251   1      }   /* DirectCommand */
 252          
 253          
 254          /*********************************************************************************************************
             -*********
 255          * º¯ÊýÃû³Æ£ºRAWwrite()
 256          * ¹¦    ÄÜ£ºÖ±½ÓÐ´Êý¾Ý»òÃüÁîµ½ÔÄ¶ÁÆ÷Ð¾Æ¬
 257          * Èë¿Ú²ÎÊý£º*pbuf           ½«Òª·¢ËÍµÄÃüÁîÊý¾Ý    
 258          *           lenght          Ð´ÈëÊý¾Ý»òÃüÁîµÄ³¤¶È    
 259          * ³ö¿Ú²ÎÊý£ºÎÞ
 260          * Ëµ    Ã÷£ºÖ±½ÓÐ´¡£
 261          **********************************************************************************************************
             -********/
 262          void RAWwrite(unsigned char *pbuf, unsigned char lenght)
 263          {
 264   1         unsigned char j;
 265   1               /*  SPI Î»Ä£Ê½ */
 266   1              /*-----------------------------------------------------------------------------*/
 267   1              L_SlaveSelect();                            //SS¹Ü½ÅÊä³öµÍ£¬SPIÆô¶¯
 268   1              while(lenght > 0)
 269   1              {
 270   2                  for(j = 0; j < 8; j++)                  //Ð´¼Ä´æÆ÷µØÖ·
 271   2                  {
 272   3                      if (*pbuf & mask)                   //ÉèÖÃÊý¾ÝÎ»
 273   3                          SIMOON();
 274   3                      else
 275   3                          SIMOOFF();
 276   3      
 277   3                      CLKON();                            //¹ØÁªCLKÊ±ÖÓÐÅÏ¢£¬·¢ËÍÊý¾Ý
 278   3                      CLKOFF();
 279   3                      mask >>= 1;                         //±êÖ¾Î»ÓÒÒÆ
 280   3                  }   /*for*/
 281   2                  mask = 0x80;
 282   2       
 283   2                  pbuf++;
 284   2                  lenght--;
 285   2              }   /* while */
 286   1      
 287   1              H_SlaveSelect();                            //SS¹Ü½ÅÊä³ö¸ß£¬SPIÍ£Ö¹
 288   1      
C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 6   

 289   1      }   /* RAWwrite */
 290          
 291          /*********************************************************************************************************
             -*********
 292          * º¯ÊýÃû³Æ£ºInitialSettings()
 293          * ¹¦    ÄÜ£º³õÊ¼»¯TRF7960ÉèÖÃ
 294          * Èë¿Ú²ÎÊý£ºÎÞ 
 295          * ³ö¿Ú²ÎÊý£ºÎÞ
 296          * Ëµ    Ã÷£ºÉèÖÃÆµÂÊÊä³ö¼°µ÷ÖÆÉî¶È
 297          **********************************************************************************************************
             -********/
 298          void InitialSettings(void)
 299          {
 300   1          unsigned char command[2];
 301   1      
 302   1          command[0] = ModulatorControl;                  
 303   1          //command[1] = 0x21;                              // µ÷ÖÆºÍÏµÍ³Ê±ÖÓ¿ØÖÆ£º0x21 - 6.78MHz OOK(100%)
 304   1          command[1] = 0x31;
 305   1        WriteSingle(command,2);
 306   1      
 307   1      }
 308          
 309          /*********************************************************************************************************
             -*********
 310          * º¯ÊýÃû³Æ£ºInterruptHandlerReader()
 311          * ¹¦    ÄÜ£ºÔÄ¶ÁÆ÷ÖÐ¶Ï´¦Àí³ÌÐò
 312          * Èë¿Ú²ÎÊý£º*Register           ÖÐ¶Ï×´Ì¬¼Ä´æÆ÷ 
 313          * ³ö¿Ú²ÎÊý£ºÎÞ
 314          * Ëµ    Ã÷£º´¦ÀíÍâ²¿ÖÐ¶Ï·þÎñ³ÌÐò
 315          *           IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷ËµÃ÷ÈçÏÂ£º
 316          *
 317          *   Î»      Î»Ãû³Æ      ¹¦ÄÜ                ËµÃ÷
 318          *   B7      Irq_tx      TX½áÊø¶øIRQÖÃÎ»         Ö¸Ê¾TXÕýÔÚ´¦ÀíÖÐ¡£¸Ã±êÖ¾Î»ÔÚTX¿ªÊ¼Ê±±»ÉèÖÃ£¬µ«ÊÇÖÐ¶ÏÇëÇóÊÇ
             -ÔÚTXÍê³ÉÊ±²Å·¢ËÍ¡£
 319          *   B6      Irq_srx     RX¿ªÊ¼¶øIRQÖÃÎ»         Ö¸Ê¾RX SOFÒÑ¾­±»½ÓÊÕµ½²¢ÇÒRXÕýÔÚ´¦ÀíÖÐ¡£¸Ã±êÖ¾Î»ÔÚRX¿ªÊ¼Ê±
             -±»ÉèÖÃ£¬µ«ÊÇÖÐ¶ÏÇëÇóÊÇÔÚRXÍê³ÉÊ±²Å·¢ËÍ¡£
 320          *   B5      Irq_fifo    Ö¸Ê¾FIFOÎª1/3>FIFO>2/3      Ö¸Ê¾FIFO¸ß»òÕßµÍ£¨Ð¡ÓÚ4»òÕß´óÓÚ8£©¡£
 321          *   B4      Irq_err1    CRC´íÎó             ½ÓÊÕCRC
 322          *   B3      Irq_err2    ÆæÅ¼Ð£Ñé´íÎó                    (ÔÚISO15693ºÍTag-itÐ­ÒéÖÐÎ´Ê¹ÓÃ)
 323          *   B2      Irq_err3    ×Ö½Ú³ÉÖ¡»òÕßEOF´íÎó 
 324          *   B1      Irq_col     ³å×²´íÎó            ISO14443AºÍISO15693µ¥¸±ÔØ²¨¡£
 325          *   B0      Irq_noresp  ÎÞÏìÓ¦ÖÐ¶Ï          Ö¸Ê¾MCU¿ÉÒÔ·¢ËÍÏÂÒ»¸ö²ÛÃüÁî¡£
 326          **********************************************************************************************************
             -********/
 327          void InterruptHandlerReader(unsigned char *Register)
 328          {
 329   1          unsigned char len;
 330   1      
 331   1      #if DBG
                  send_byte(*Register);                            //·¢ËÍÈë¿Ú²ÎÊýÖµ
              #endif
 334   1      
 335   1          if(*Register == 0xA0)                           //A0 = 10100000 Ö¸Ê¾TX·¢ËÍ½áÊø£¬²¢ÇÒÔÚFIFOÖÐÊ£ÏÂ3×Ö½ÚÊ
             -ý¾Ý
 336   1          {                
 337   2              i_reg = 0x00;
 338   2      #if DBG
                      sendchar('.');                              //ÔÚ´«ËÍ¹ý³ÌÖÐFIFOÒÑ¾­±»Ìî³ä
              #endif
 341   2          }
 342   1      
 343   1          else if(*Register == 0x80)                      //BIT7 = 10000000 Ö¸Ê¾TX·¢ËÍ½áÊø
C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 7   

 344   1          {            
 345   2              i_reg = 0x00;
 346   2              *Register = Reset;                          //ÔÚTX·¢ËÍ½áÊøºó Ö´ÐÐ¸´Î»²Ù×÷
 347   2              DirectCommand(Register);
 348   2      #if DBG
                      sendchar('T');                              //TX·¢ËÍ½áÊø
              #endif
 351   2          }
 352   1      
 353   1          else if((*Register & 0x02) == 0x02)             //BIT1 = 00000010 ³å×²´íÎó
 354   1          {                           
 355   2              i_reg = 0x02;                               //ÉèÖÃRX½áÊø
 356   2      
 357   2              *Register = StopDecoders;                   //ÔÚTX·¢ËÍ½áÊøºó¸´Î»FIFO
 358   2              DirectCommand(Register);
 359   2      
 360   2              CollPoss = CollisionPosition;
 361   2              ReadSingle(&CollPoss, 1);
 362   2      
 363   2              len = CollPoss - 0x20;                      //»ñÈ¡FIFOÖÐµÄÓÐÐ§Êý¾Ý×Ö½ÚÊýÁ¿
 364   2      #if DBG
                      sendchar('{');
                      send_byte(CollPoss);                     //·¢ËÍ³å×²·¢ÉúµÄÎ»ÖÃ
                      sendchar('}');
              #endif     
 369   2              
 370   2              if((len & 0x0f) != 0x00) 
 371   2                  len = len + 0x10;                       //Èç¹û½ÓÊÕµ½²»ÍêÕû×Ö½Ú£¬Ôò¼ÓÉÏÒ»¸ö×Ö½Ú
 372   2              len = len >> 4;
 373   2      
 374   2              if(len != 0x00)
 375   2              {
 376   3                  buf[RXTXstate] = FIFO;                  //½«½ÓÊÕµ½µÄÊý¾ÝÐ´µ½»º³åÇøµÄµ±Ç°Î»ÖÃ                  
             -             
 377   3                  ReadCont(&buf[RXTXstate], len);
 378   3                  RXTXstate = RXTXstate + len;
 379   3              }   /* if */
 380   2      
 381   2              *Register = Reset;                          //Ö´ÐÐ¸´Î»ÃüÁî
 382   2              DirectCommand(Register);
 383   2      
 384   2              *Register = IRQStatus;                      //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 385   2              *(Register + 1) = IRQMask;
 386   2      
 387   2                  ReadCont(Register, 2);
 388   2         
 389   2              IRQCLR();                                   //ÇåÖÐ¶Ï
 390   2          }
 391   1          else if(*Register == 0x40)                      //BIT6 = 01000000 ½ÓÊÕ¿ªÊ¼
 392   1          {   
 393   2              if(RXErrorFlag == 0x02)                     //RX½ÓÊÕ±êÖ¾Î»Ö¸Ê¾EOFÒÑ¾­±»½ÓÊÕ£¬²¢ÇÒÖ¸Ê¾ÔÚFIFO¼Ä´æÆ÷Ö
             -ÐÎ´±»¶Á×Ö½ÚµÄÊýÁ¿
 394   2              {
 395   3                  i_reg = 0x02;
 396   3                  return;
 397   3              }
 398   2      
 399   2              *Register = FIFOStatus;
 400   2              ReadSingle(Register, 1);                    //¶ÁÈ¡ÔÚFIFOÖÐÊ£ÏÂ×Ö½ÚµÄÊýÁ¿
 401   2              *Register = (0x0F & *Register) + 0x01;
 402   2              buf[RXTXstate] = FIFO;                      //½«½ÓÊÕµ½µÄÊý¾ÝÐ´µ½»º³åÇøµÄµ±Ç°Î»ÖÃ
 403   2                                                                                        
C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 8   

 404   2              ReadCont(&buf[RXTXstate], *Register);
 405   2              RXTXstate = RXTXstate +*Register;
 406   2      
 407   2              *Register = TXLenghtByte2;                  //¶ÁÈ¡ÊÇ·ñÓÐ²»ÍêÕûµÄ×Ö½Ú¼°ÆäÎ»ÊýÁ¿
 408   2              ReadCont(Register, 1);
 409   2      
 410   2              if((*Register & 0x01) == 0x01)              //00000001 ÎÞÏìÓ¦ÖÐ¶Ï
 411   2              {
 412   3                  *Register = (*Register >> 1) & 0x07;    //±ê¼ÇÇ°5Î»
 413   3                  *Register = 8 - *Register;
 414   3                  buf[RXTXstate - 1] &= 0xFF << *Register;
 415   3              }   /* if */
 416   2               
 417   2      #if DBG
                      sendchar('E');                              //·¢ËÍÎÞÏìÓ¦±êÖ¾ E
              #endif
 420   2              *Register = Reset;                          //×îºóÒ»¸ö×Ö½Ú±»¶ÁÈ¡ºó¸´Î»FIFO
 421   2              DirectCommand(Register);
 422   2      
 423   2              i_reg = 0xFF;                               //Ö¸Ê¾½ÓÊÕº¯ÊýÕâÐ©×Ö½ÚÒÑ¾­ÊÇ×îºó×Ö½Ú
 424   2          }
 425   1          else if(*Register == 0x60)                      //0x60 = 01100000 RXÒÑ¾­Íê±Ï ²¢ÇÒÓÐ9¸ö×Ö½ÚÔÚFIFOÖÐ
 426   1          {                            
 427   2              i_reg = 0x01;                               //ÉèÖÃ±êÖ¾Î»
 428   2              buf[RXTXstate] = FIFO;
 429   2              ReadCont(&buf[RXTXstate], 9);               //´ÓFIFOÖÐ¶ÁÈ¡9¸ö×Ö½ÚÊý¾Ý
 430   2              RXTXstate = RXTXstate + 9;
 431   2      #if DBG
                      sendchar('F');                              //·¢ËÍ F ±íÊ¾FIFO»º³åÇøÂú
              #endif
 434   2              if(IRQPORT & IRQPin)                        //Èç¹ûÖÐ¶Ï¹Ü½ÅÎª¸ßµçÆ½
 435   2              {
 436   3                  *Register = IRQStatus;                  //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 437   3                  *(Register + 1) = IRQMask;
 438   3                                  //¶ÁÈ¡¼Ä´æÆ÷
 439   3                      ReadCont(Register, 2);
 440   3               
 441   3                  IRQCLR();                               //ÇåÖÐ¶Ï
 442   3      
 443   3                  if(*Register == 0x40)                   //0x40 = 01000000 ½ÓÊÕ½áÊø
 444   3                  {  
 445   4                      *Register = FIFOStatus;
 446   4                      ReadSingle(Register, 1);            //¶ÁÈ¡ÔÚFIFOÖÐÊ£ÏÂ×Ö½ÚµÄÊýÁ¿
 447   4                      *Register = 0x0F & (*Register + 0x01);
 448   4                      buf[RXTXstate] = FIFO;              //½«½ÓÊÕµ½µÄÊý¾ÝÐ´µ½»º³åÇøµÄµ±Ç°Î»ÖÃ
 449   4                                                                                        
 450   4                      ReadCont(&buf[RXTXstate], *Register);
 451   4                      RXTXstate = RXTXstate +*Register;
 452   4      
 453   4                      *Register = TXLenghtByte2;          //¶ÁÈ¡ÊÇ·ñÓÐ²»ÍêÕûµÄ×Ö½Ú¼°ÆäÎ»ÊýÁ¿
 454   4                      ReadSingle(Register, 1);         
 455   4      
 456   4                      if((*Register & 0x01) == 0x01)      //00000001 ÎÞÏìÓ¦ÖÐ¶Ï
 457   4                      {
 458   5                          *Register = (*Register >> 1) & 0x07;            //±ê¼ÇÇ°5Î»
 459   5                          *Register = 8 -*Register;
 460   5                          buf[RXTXstate - 1] &= 0xFF << *Register;
 461   5                      }   /* if */
 462   4      #if DBG
                              sendchar('E');                      //·¢ËÍÎÞÏìÓ¦±êÖ¾ E
              #endif
 465   4                      i_reg = 0xFF;                       //Ö¸Ê¾½ÓÊÕº¯ÊýÕâÐ©×Ö½ÚÒÑ¾­ÊÇ×îºó×Ö½Ú
C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 9   

 466   4                      *Register = Reset;                  //ÔÚ×îºó×Ö½Ú±»¶ÁÈ¡ºó¸´Î»FIFO
 467   4                      DirectCommand(Register);
 468   4                  }
 469   3                  else if(*Register == 0x50)              //0x50 = 01010000½ÓÊÕ½áÊø²¢ÇÒ·¢ÉúCRC´íÎó
 470   3                  {        
 471   4                      i_reg = 0x02;
 472   4      #if DBG
                              sendchar('x');                      //·¢ËÍCRCÐ£Ñé´íÎó±êÖ¾ x
              #endif
 475   4                  }
 476   3              }   /* if(IRQPORT & IRQPin) */
 477   2              else                                        
 478   2              {
 479   3                  Register[0] = IRQStatus;                //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 480   3                  Register[1] = IRQMask;
 481   3                  
 482   3                      ReadCont(Register, 2);              //¶ÁÈ¡¼Ä´æÆ÷
 483   3                
 484   3                  
 485   3                  if(Register[0] == 0x00) 
 486   3                    i_reg = 0xFF;                         //Ö¸Ê¾½ÓÊÕº¯ÊýÕâÐ©×Ö½ÚÒÑ¾­ÊÇ×îºó×Ö½Ú
 487   3              }
 488   2          }
 489   1          else if((*Register & 0x10) == 0x10)             //BIT4 = 00010000 Ö¸Ê¾CRC´íÎó
 490   1          {                      
 491   2              if((*Register & 0x20) == 0x20)              //BIT5 = 00100000 Ö¸Ê¾FIFOÖÐÓÐ9¸ö×Ö½Ú
 492   2              {
 493   3                  i_reg = 0x01;                           //½ÓÊÕÍê³É
 494   3                  RXErrorFlag = 0x02;
 495   3              }
 496   2              else
 497   2                  i_reg = 0x02;                           //Í£Ö¹½ÓÊÕ        
 498   2          }
 499   1          else if((*Register & 0x04) == 0x04)             //BIT2 = 00000100  ×Ö½Ú³ÉÖ¡»òÕßEOF´íÎó
 500   1          {                       
 501   2              if((*Register & 0x20) == 0x20)              //BIT5 = 00100000 Ö¸Ê¾FIFOÖÐÓÐ9¸ö×Ö½Ú
 502   2              {
 503   3                  i_reg = 0x01;                           //½ÓÊÕÍê³É
 504   3                  RXErrorFlag = 0x02;
 505   3              }
 506   2              else
 507   2                  i_reg = 0x02;                           //Í£Ö¹½ÓÊÕ 
 508   2          }
 509   1          else if(*Register == 0x01)                      //BIT0 = 00000001 ÖÐ¶ÏÎÞÓ¦´ð
 510   1          {                      
 511   2              i_reg = 0x00;
 512   2      #if DBG
                      sendchar('N');
              #endif
 515   2          }
 516   1          else
 517   1          {     
 518   2      #if DBG    
                      send_cstring("Interrupt error");        //·¢ËÍÖÐ¶Ï´íÎó
                      send_byte(*Register);
              #endif        
 522   2              i_reg = 0x02;
 523   2      
 524   2              *Register = StopDecoders;                   //ÔÚTX·¢ËÍ½ÓÊÕºó¸´Î»FIFO
 525   2              DirectCommand(Register);
 526   2      
 527   2              *Register = Reset;
C51 COMPILER V9.57.0.0   COMMUNICATE                                                       04/14/2019 22:22:19 PAGE 10  

 528   2              DirectCommand(Register);
 529   2      
 530   2              *Register = IRQStatus;                      //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 531   2              *(Register + 1) = IRQMask;
 532   2      
 533   2             
 534   2                  ReadCont(Register, 2);                  //¶ÁÈ¡¼Ä´æÆ÷
 535   2              
 536   2              IRQCLR();                                   //ÇåÖÐ¶Ï
 537   2          }
 538   1      }   /* InterruptHandlerReader */
 539          
 540          /********************************************************************************************************
 541          * º¯ÊýÃû³Æ£ºPort_0()
 542          * ¹¦    ÄÜ£ºÔÄ¶ÁÆ÷ÖÐ¶ÏÈë¿Ú³ÌÐò
 543          * Èë¿Ú²ÎÊý£ºÎÞ
 544          * ³ö¿Ú²ÎÊý£ºÎÞ
 545          * Ëµ    Ã÷£º´¦ÀíÍâ²¿ÖÐ¶Ï·þÎñ³ÌÐò
 546          *********************************************************************************************************/
 547          void Port_0(void) interrupt 0     
 548          {
 549   1          unsigned char Register[4];
 550   1      
 551   1          StopCounter();                                  //¶¨Ê±Æ÷Í£Ö¹
 552   1          
 553   1          do
 554   1          {
 555   2              IRQCLR();                                   //Çå¶Ë¿Ú2ÖÐ¶Ï±êÖ¾Î»
 556   2              Register[0] = IRQStatus;                    //»ñÈ¡IRQÖÐ¶Ï×´Ì¬¼Ä´æÆ÷µØÖ·
 557   2              Register[1] = IRQMask;                      //ÐéÄâ¶Á Dummy read                                 
 558   2              ReadCont(Register, 2); //¶ÁÈ¡¼Ä´æÆ÷
 559   2              //send_byte(*Register);
 560   2              if(*Register == 0xA0)                       //A0 = 10100000 Ö¸Ê¾TX·¢ËÍ½áÊø£¬²¢ÇÒÔÚFIFOÖÐÊ£ÏÂ3×Ö½ÚÊ
             -ý¾Ý
 561   2              {   
 562   3                  goto FINISH;                            //Ìø×ªµ½FINISH´¦£¬½øÈëµÍ¹¦ºÄÄ£Ê½
 563   3              }
 564   2              
 565   2              InterruptHandlerReader(Register);       //Ö´ÐÐÖÐ¶Ï·þÎñ³ÌÐò
 566   2              
 567   2          }while((IRQPORT & IRQPin) == IRQPin);           //Ìõ¼þÖ´ÐÐ
 568   1      FINISH:
 569   1         PCON &= ~0X02;
 570   1        // return;
 571   1      }
 572          
 573          
 574          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2216    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      3      37
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
